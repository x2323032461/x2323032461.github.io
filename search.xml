<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>文件结构</title>
    <url>/2021/02/23/etc/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><h3 id="etc-其他"><a href="#etc-其他" class="headerlink" title="etc  其他"></a>etc  其他</h3><p>一般用来存放配置文件</p>
<a id="more"></a>



<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="md"><a href="#md" class="headerlink" title=".md"></a>.md</h3><p>用来标注Markdown文件</p>
<h3 id="ios"><a href="#ios" class="headerlink" title=".ios"></a>.ios</h3><p>一种光盘（CD）上的文件系统格式。简单地说，就是数据在数据光盘上的组织形式</p>
<p><img src="image-20210303093655987.png" alt="image-20210303093655987"></p>
<h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><h3 id="C-S"><a href="#C-S" class="headerlink" title="C/S"></a>C/S</h3><p>Client-Server（服务器-客户机）</p>
<p><img src="20151230125752551.png" alt="img"></p>
<h3 id="B-S"><a href="#B-S" class="headerlink" title="B/S"></a>B/S</h3><p>Browser-Server，B/S结构即浏览器和服务器结构。</p>
<p><img src="20151230125834981.png" alt="img"></p>
]]></content>
      <categories>
        <category>etc</category>
      </categories>
      <tags>
        <tag>文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat</title>
    <url>/2021/02/25/%E8%BD%AF%E4%BB%B6/Navicat/</url>
    <content><![CDATA[<h2 id="Navicat快捷键"><a href="#Navicat快捷键" class="headerlink" title="Navicat快捷键"></a>Navicat快捷键</h2><a id="more"></a>

<blockquote>
<h4 id="执行选中的sql语句-run"><a href="#执行选中的sql语句-run" class="headerlink" title="执行选中的sql语句  run"></a>执行选中的sql语句  run</h4></blockquote>
<p>Ctrl + shift + R</p>
<blockquote>
<h4 id="执行窗口的sql语句"><a href="#执行窗口的sql语句" class="headerlink" title="执行窗口的sql语句"></a>执行窗口的sql语句</h4></blockquote>
<p>Ctrl + R</p>
<blockquote>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4></blockquote>
<p>Ctrl + /</p>
<blockquote>
<h4 id="解除注释"><a href="#解除注释" class="headerlink" title="解除注释"></a>解除注释</h4></blockquote>
<p>Ctrl + shift + /</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>前端报错汇总</title>
    <url>/2021/02/22/web/%E5%89%8D%E7%AB%AF%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h3><p><strong>net::ERR_CONNECTION_REFUSED</strong></p>
<a id="more"></a>

<p>错误连接被拒绝</p>
<p>1，有可能是网络原因   2，有可能是请求地址错误</p>
<h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>4**</p>
<table>
<thead>
<tr>
<th>常用错误码</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>参数有误</td>
</tr>
<tr>
<td>401</td>
<td>需要进行身份认证</td>
</tr>
<tr>
<td>403</td>
<td>请求没问题，但是后台拒绝响应，可能为身份未认证或其他原因(后台可以告诉也可以不告诉)</td>
</tr>
<tr>
<td>404</td>
<td>资源无法找到</td>
</tr>
</tbody></table>
<p><strong>详细错误码</strong></p>
<table>
<thead>
<tr>
<th>错误码</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>400 Bad_Request</td>
<td>1. 语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求；2. 请求参数有误。</td>
</tr>
<tr>
<td>401 Unauthorized</td>
<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>
</tr>
<tr>
<td>402 Payment Required</td>
<td>该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td>403 Forbidden</td>
<td>服务器已经理解请求，但是拒绝执行它，与401不同的是，401并不能提供任何帮助，而403如果这不是一个 HEAD 请求，服务器希望能够讲清楚为何请求不能被执行，那么就可以在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td>404 Not_Found</td>
<td>请求失败，请求所希望得到的资源未被在服务器上发现。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。</td>
</tr>
<tr>
<td>405 Method Not Allowed</td>
<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>
</tr>
<tr>
<td>406 Not Acceptable</td>
<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。  除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。<br />实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td>407 Proxy Authentication Required</td>
<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。</td>
</tr>
<tr>
<td>408 Request Timeout</td>
<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td>409 Conflict</td>
<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<br />冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td>410 Gone</td>
<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用<a href="https://baike.baidu.com/item/404%E7%8A%B6%E6%80%81%E7%A0%81/12678394">404状态码</a>。除非额外说明，否则这个响应是可缓存的。<br />410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td>411 Length Required</td>
<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td>412 Precondition Failed</td>
<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td>413 Request Entity Too Large</td>
<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br />如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td>414 Request-URI Too Long</td>
<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：<br />本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<br />重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。<br />客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生<a href="https://baike.baidu.com/item/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/678453">缓冲区溢出</a>，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>
</tr>
<tr>
<td>415 Unsupported Media Type</td>
<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td>416 Requested Range Not Satisfiable</td>
<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。<br />假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td>417 Expectation Failed</td>
<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td>418 I’m a teapot</td>
<td></td>
</tr>
<tr>
<td>421 Misdirected Request</td>
<td>请求被指向到无法生成响应的服务器（比如由于连接重复使用）</td>
</tr>
<tr>
<td>422 Unprocessable Entity</td>
<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>423 Locked</td>
<td>当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>424 Failed Dependency</td>
<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>425 Too Early</td>
<td>状态码 425 Too Early 代表服务器不愿意冒风险来处理该请求，原因是处理该请求可能会被“重放”，从而造成潜在的重放攻击。（RFC 8470） [1]</td>
</tr>
<tr>
<td>426 Upgrade Required</td>
<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td>449 Retry With</td>
<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
<tr>
<td>451 Unavailable For Legal Reasons</td>
<td>该请求因法律原因不可用。（RFC 7725）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title>收藏</title>
    <url>/2021/03/18/%E6%94%B6%E8%97%8F/%E6%94%B6%E8%97%8F/</url>
    <content><![CDATA[<h2 id="学习网-狂神"><a href="#学习网-狂神" class="headerlink" title="学习网(狂神)"></a>学习网(狂神)</h2><p>​    <a href="https://www.kuangstudy.com/">https://www.kuangstudy.com/</a></p>
<p>手机vpn</p>
<p><a href="https://www.haoxixin.com/cn/?a=ez">https://www.haoxixin.com/cn/?a=ez</a></p>
<p>DeepNude</p>
<p><a href="https://www.fujieace.com/jingyan/deepnude2-0.html">https://www.fujieace.com/jingyan/deepnude2-0.html</a></p>
<p>破解资源下载</p>
<p><a href="http://www.fulinian.com/">http://www.fulinian.com/</a></p>
<p>java链式编程</p>
<p><a href="https://blog.csdn.net/u013822349/article/details/81128307">https://blog.csdn.net/u013822349/article/details/81128307</a></p>
<p>学习PDF下载</p>
<p><a href="http://www.java1234.com/">http://www.java1234.com/</a></p>
<p>流程图</p>
<p><a href="https://www.processon.com/">https://www.processon.com</a></p>
<p>数据库排名</p>
<p><a href="https://db-engines.com/">https://db-engines.com</a></p>
<p>google应用商店</p>
<p><a href="https://chrome.google.com/webstore/category/extensions?hl=zh">https://chrome.google.com/webstore/category/extensions?hl=zh</a></p>
<p>OSCHINA(类CSDN)</p>
<p><a href="https://www.oschina.net/">https://www.oschina.net/</a></p>
<p>maven库</p>
<p><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
<p>淘宝镜像站</p>
<p><a href="https://developer.aliyun.com/mirror/?spm=a2c6h.14029880.0.d1002.735975d7bRRK09">https://developer.aliyun.com/mirror/?spm=a2c6h.14029880.0.d1002.735975d7bRRK09</a></p>
<p><a href="https://mirrors.aliyun.com/centos/8/isos/x86_64/">https://mirrors.aliyun.com/centos/8/isos/x86_64/</a></p>
<p><strong>1.1</strong>  <strong>搜索引擎</strong></p>
<p>1.1、秘迹搜索</p>
<p>一款无敌有良心、无敌安全的搜索引擎，不会收集私人信息，保护私隐，没有Cookie，并且秘迹搜索聚合了百度、360、Bing、搜狗等搜索结果。</p>
<p>网站：<a href="https://mijisou.com/">https://mijisou.com</a></p>
<p>ymdd17</p>
<p><a href="https://cn.ad101.vip/">https://cn.ad101.vip/</a></p>
<p>1.2、小白盘</p>
<p>度盘资源搜索的网站，能够搜索电影、电视剧、小说、音乐等资源</p>
<p>网站：<a href="https://www.xiaobaipan.com/">https://www.xiaobaipan.com</a></p>
<p><strong>1.2</strong>  <strong>PPT</strong></p>
<p>2.1、优品PPT</p>
<p>高品质免费PPT模板下载网站，比第一PPT质量高很多。</p>
<p>网站：<a href="http://www.ypppt.com/">http://www.ypppt.com</a></p>
<p><strong>1.3</strong>  <strong>图片操作</strong></p>
<p>3.1、图片无限变大</p>
<p>让你的图片无损放大，放大，再放大！只需要稍稍处理一下就可达到意想不到的效果。</p>
<p>网站：<a href="http://bigjpg.com/zh">http://bigjpg.com/zh</a></p>
<p><strong>1.4</strong>  <strong>文件共享</strong></p>
<p>4.1、拷贝兔</p>
<p>拷贝兔是款跨平台文件传输工具，能做到不同设备间文件或文本的临时性迅速分享的应用，支持Windows、Mac、Linux、iOS、Android平台互传；在线使用，用完即走。比百度网盘方便多了。</p>
<p>网站：<a href="https://cp.anyknew.com/">https://cp.anyknew.com</a></p>
<p><strong>1.5</strong>  <strong>应届生招聘</strong></p>
<p>5.1、应届生求职网</p>
<p>为大学生提供全方位的求职服务，提供最全、最新、最准确的校园宣讲、全职招聘、兼职实习、知名企业校园招聘、现场招聘会等信息，并且为大学生提供针对性的求职就业指导。</p>
<p>网站：<a href="http://s.yingjiesheng.com/">http://s.yingjiesheng.com/</a></p>
<p><strong>1.6</strong>  <strong>程序员面试题库</strong></p>
<p>6.1、LeetCode（力扣）</p>
<p>力扣题库，提供海量技术面试资源。</p>
<p>网站：<a href="https://leetcode-cn.com/">https://leetcode-cn.com/</a></p>
<p><strong>1.7</strong>  <strong>办公、开发软件</strong></p>
<p>7.1、我爱分享网</p>
<p>分享各种常用软件安装包，安装教程和自学视频，让小伙伴即时获取最新的软件，软件无忧，理工科必备利器！</p>
<p>网站：<a href="http://www.zhanshaoyi.com/rjxz.html">http://www.zhanshaoyi.com/rjxz.html</a></p>
<p><strong>1.8</strong>  <strong>mysql铁律</strong></p>
<p><a href="https://blog.csdn.net/smartbetter/article/details/100160069">https://blog.csdn.net/smartbetter/article/details/100160069</a></p>
<p><strong>1.9</strong>  <strong>前端教程</strong></p>
<p><a href="https://www.w3school.com.cn/">https://www.w3school.com.cn</a></p>
<p><strong>1.10</strong> <strong>题库</strong></p>
<p>leetcode</p>
<p><strong>1.11</strong> <strong>论坛</strong></p>
<p>csdn</p>
<p> <a href="https://tool.lu/">https://tool.lu/</a></p>
<p><strong>1.12</strong> <strong>导航网</strong></p>
<p><a href="https://www.bootcss.com/">https://www.bootcss.com/</a></p>
<p><strong>1.13</strong> <strong>国外IT学习网站镜像(纯英文)</strong></p>
<p><a href="https://www.quanzhanketang.com/">https://www.quanzhanketang.com/</a></p>
<p><strong>1.14</strong> <strong>加密</strong></p>
<p><strong>1.14.1</strong> <strong>加密工具</strong></p>
<p><a href="http://tool.oschina.net/encrypt">http://tool.oschina.net/encrypt</a></p>
<p><strong>1.14.2</strong> <strong>AES加密页面</strong></p>
<p><a href="http://tool.chacuo.net/cryptaes">http://tool.chacuo.net/cryptaes</a></p>
<p><strong>1.14.3</strong> <strong>其他较全加密页面</strong></p>
<p><a href="http://tool.oschina.net/encrypt/">http://tool.oschina.net/encrypt/</a></p>
<p><strong>1.15</strong> <strong>jar包下载</strong></p>
<p><a href="https://mvnrepository.com/artifact/org.apache.axis/axis/1.4">https://mvnrepository.com/artifact/org.apache.axis/axis/1.4</a></p>
<p><strong>1.16</strong> <strong>图扑</strong></p>
<p>heightopo    </p>
<p><strong>1.17</strong> <strong>课件购买</strong></p>
<p><a href="https://xiedaimala.com/">https://xiedaimala.com/</a></p>
<p><strong>1.18</strong> <strong>脚本网址</strong></p>
<p><a href="https://greasyfork.org/zh-CN/scripts">https://greasyfork.org/zh-CN/scripts</a></p>
<p><strong>1.19</strong> <strong>maven 库</strong></p>
<p><a href="https://mvnrepository.com/tags/ftp">https://mvnrepository.com/tags/ftp</a></p>
]]></content>
      <categories>
        <category>收藏</category>
      </categories>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title>idea</title>
    <url>/2021/03/09/%E8%BD%AF%E4%BB%B6/idea/</url>
    <content><![CDATA[<h2 id="代码自动缩进行-格式整理"><a href="#代码自动缩进行-格式整理" class="headerlink" title="代码自动缩进行(格式整理)"></a>代码自动缩进行(格式整理)</h2><a id="more"></a>

<p>settings –&gt; Keymap –&gt; Main menu –&gt; Code –&gt; Auto-Indent Lines</p>
<p><img src="image-20210309145729038.png" alt="image-20210309145729038"></p>
<h2 id="清除idea缓存"><a href="#清除idea缓存" class="headerlink" title="清除idea缓存"></a>清除idea缓存</h2><p><img src="image-20210309165824345.png" alt="image-20210309165824345"></p>
<h2 id="多项目启动展示-Group-Tabs"><a href="#多项目启动展示-Group-Tabs" class="headerlink" title="多项目启动展示-Group Tabs"></a>多项目启动展示-Group Tabs</h2><p><img src="image-20210312093529999.png" alt="image-20210312093529999"></p>
<p>未打钩时</p>
<p><img src="image-20210312093617360.png" alt="image-20210312093617360"></p>
<p>打钩时</p>
<p><img src="image-20210312093643838.png" alt="image-20210312093643838"></p>
<h2 id="项目启动报错"><a href="#项目启动报错" class="headerlink" title="项目启动报错"></a>项目启动报错</h2><p>错误重现，用run模式启动项目的时候没出现此问题，但是使用debug模式下启动项目的时候就出现此问题。</p>
<p><img src="idea/903105852599.png" alt="img"></p>
<p><strong>解决方案！</strong></p>
<p>  修改项目下 .idea\workspace.xml，找到标签 <strong><component name="PropertiesComponent"></strong> ， 在标签里加一行 </p>
<p><strong><property name="dynamic.classpath" value="true" /></strong></p>
]]></content>
      <categories>
        <category>软件</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>其他</title>
    <url>/2021/03/08/%E8%BF%9B%E5%BA%A6/%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<p>脱敏处理</p>
<a id="more"></a>

<p>js宏观任务和微观任务</p>
<p>线性代数和数据结构算法</p>
]]></content>
  </entry>
  <entry>
    <title>单词</title>
    <url>/2021/03/05/%E8%BF%9B%E5%BA%A6/%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><a id="more"></a>

<p>JetBrains</p>
<h2 id="😱-🧐"><a href="#😱-🧐" class="headerlink" title="😱  🧐"></a>😱  🧐</h2><p>method        方法</p>
<p>field             字段</p>
<p>parameter    参数</p>
<p>constructor    构造方法</p>
<p>local variable    局部变量</p>
<p>annotation    注释、注解</p>
<p>package        包</p>
<p>generate        生成</p>
<p>deploy        部署</p>
<p>menu        菜单</p>
<p>category    类别</p>
<p>business     业务、事务</p>
<p>tag             标签</p>
<p>destroy        销毁</p>
<p>release         稳定版本  </p>
<p>debug         内部测试版本</p>
<p>exist          存在</p>
<p>component    组件</p>
<p>engine          引擎</p>
<p>schema        计划的提纲</p>
<p>studio             工作室</p>
<p>operation    log    操作 日志</p>
<p>middle          中部</p>
<p>concurrent      并发</p>
<p>arguments     论点</p>
<p>empty         空的</p>
<p>prototype      原型</p>
<p>instance        例子、实例</p>
<p>front         前面</p>
<p>common        常见的</p>
<p>community    社区</p>
<p>configuration    配置</p>
<p>Suppress     抑制；镇压；废止 </p>
<p>Warnings        警告</p>
<p>declared        公开的</p>
<p>cycle        周期</p>
<p>tail            跟踪</p>
<p>detail        详情</p>
<p>Elastic         弹性</p>
<p>Search        搜索</p>
<p>stack        堆栈</p>
<p>Ranking        排名</p>
<p>addr            地址</p>
<p>Beats        心跳</p>
<h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><p>broker        经纪人(服务器)</p>
<p>topic            主题</p>
<p>partition        分隔、隔断、分区</p>
<p>leader        领导</p>
<p>follower        跟随者</p>
<p>producer        生产者</p>
<p>consumer    消费者</p>
<p>cluster        集群</p>
<p>software        软件</p>
<p>unique        唯一</p>
<p>upper respiratory infection    上呼吸道感染</p>
<h2 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h2><p>shard        切片，碎片</p>
<p>pretty        漂亮的，美观的</p>
<p>bulk            大量的</p>
<p>zookeeper</p>
<p>event        事件</p>
<p>access        访问</p>
<p>scheme        方案</p>
<p>valid            有效的</p>
<p>authentication    身份验证</p>
<p>await        等待</p>
<p>expire        期满，超时</p>
<p>cyclic        循环        sai ke lei ke </p>
<p>barrier        屏障        bai rui er</p>
<p>atomic        原子的</p>
<p>grep            正则表达式</p>
<p>transaction    事务</p>
<p>acquire        获取</p>
<p>release        释放</p>
<p>core            核心</p>
<p>current        现在的</p>
<p>observer        观察者</p>
<p>subject        主题</p>
<p>register        登记</p>
<p>notify        通知</p>
<p>arguments     论据、论点</p>
<p>site            网站</p>
<p>apologize     道歉</p>
<p>insult        侮辱</p>
<p>truth            真理</p>
<p>westerns        西部的  西方？</p>
<p>difference     不同</p>
<p>human rights    人权</p>
<p>How dare they    他们怎么敢</p>
<p>feel ashame    感到羞耻</p>
<p>tax             税收</p>
<p>technology    技术</p>
<p>splunk        si pu lan ke</p>
]]></content>
      <categories>
        <category>进度</category>
      </categories>
      <tags>
        <tag>进度</tag>
      </tags>
  </entry>
  <entry>
    <title>进度</title>
    <url>/2021/02/23/%E8%BF%9B%E5%BA%A6/%E8%BF%9B%E5%BA%A6/</url>
    <content><![CDATA[<p>​    <del>——</del></p>
<a id="more"></a>

<p>​    <del>git    2021-03-01</del></p>
<p>==docker   p9 5.00==</p>
<p>kafka</p>
<p>多线程详解</p>
<p>注解和反射</p>
<p>如何备战秋招</p>
<p>k8s-Kubernetes</p>
]]></content>
      <categories>
        <category>进度</category>
      </categories>
      <tags>
        <tag>进度</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2021/03/08/%E8%BF%9B%E5%BA%A6/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><a id="more"></a>

<blockquote>
<h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象?"></a>什么是面向对象?</h3></blockquote>
<p>对比面向过程，是两种不同的处理问题的角度:</p>
<p>面向过程更注重事情的每一个步骤及顺序, 面向对象更注重事情有哪些参与者(对象)、及各自需要做什么比如:洗衣机洗衣服</p>
<p>面向过程会将任务拆解成一系列的步骤(函数)，1. 打开洗衣机—&gt;2.放衣—&gt;3.放洗衣—-&gt;4. 清洗—–&gt;5.烘干</p>
<p>面向对象会拆出人和洗衣机两个对象:</p>
<p>人: 打开洗衣机、放衣服、放洗衣粉</p>
<p>洗衣机: 清洗、烘干</p>
<p>从以上例子能看出，==面向过程比较直接高效==,而==面向对象更易于复用、扩展和维护==</p>
<blockquote>
<h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3></blockquote>
<p>==封装==：封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项<br>外部调用无需修改或者关心内部实现</p>
<ol>
<li><code>javabean</code>的属性私有，提供get\set对外访问， 因为属性的赋值或者获取逻辑只能由<code>javabean</code>本身决定。而不能<br>由外部胡乱修改</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该类name属性有自身的命名规范，明显不能由外部直接赋值</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">&quot;姓_&quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>orm框架</p>
<p>操作数据库时，操作者不需要关心链接如何建立，sql如何执行，只需引入mybatis，调用方法即可</p>
</li>
</ol>
<p>==继承==：继承基类的方法，并做出自己的改变或扩展</p>
<p>子类共性的方法或者属性直接使用父类的,而不需要自己再定义，只需扩展自己个性化的</p>
<p>==多态==：基于对象所属类的不同,外部对同一个方法的调用,实际执行的逻辑不同。</p>
<h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2>]]></content>
      <categories>
        <category>进度</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2021/03/18/%E7%AE%97%E6%B3%95/%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度</title>
    <url>/2021/03/18/%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="代码执行次数"><a href="#代码执行次数" class="headerlink" title="代码执行次数"></a>代码执行次数</h3><p>调用一次函数fun1，内部一共执行<code>2</code>次语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 执行1次</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;打印&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行1次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>调用一次函数fun2，内部一共执行<code>3n+3</code>次语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; n; index++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>循环执行顺序</p>
<p><img src="%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20210318150805260.png" alt="image-20210318150805260"></p>
<p>由此可以看出（在循环仅运行一次，循环体中代码至少执行一次的情况下）：</p>
<ol>
<li>参数index初始化仅会执行一次</li>
<li>自增部分及循环体执行次数为n</li>
<li>由于循环以判断开始最后也以判断终止，因此判断会比循环体中的代码多执行一次，即n+1</li>
<li>return 执行次数为一</li>
</ol>
<p>因此总的执行次数为3n+3</p>
<h3 id="代码的总执行次数"><a href="#代码的总执行次数" class="headerlink" title="代码的总执行次数"></a>代码的总执行次数</h3><p>一段代码的总执行次数会用T(n)表示</p>
<p>n是输入数据的大小或数量</p>
<p>T（n）表示输入为n时，某段代码的总执行次数</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>若某段代码的T(n) = 常数</p>
<p>那么这段代码的时间复杂度可以直接估算为1</p>
<p>因此T(n) = 2 的时间复杂度就是 1,<code>即 O(1)</code></p>
<p>若代码的T(n) = 常数 * n + 常数</p>
<p>当n不断扩大时，第一部分常数*n会不断扩大，而第二部分的常数相对于第一部分就没有那么重要了，就相当于不存在，因此可以直接省略</p>
<p>而第一部分的常数可以直接估算为1，也可以直接理解为去掉这个常数</p>
<p>因此T(n) = 3n+3的时间复杂度就是  n,<code>即 O(n)</code></p>
<p>而对于带有次方的项T(n) = 常数*n^3 + 常数*n^2</p>
<p>当n不断扩大时，次方大的部分n的扩大更明显，而次方小的部分扩大不明显，因此可以直接省略</p>
<p>之后常数估算为1</p>
<p>因此T(n) = 常数*n^3 + 常数*n^2的时间复杂度为 n^3,<code>即 O(n^3)</code></p>
<p><strong>总结： 而仅用n表示的时间复杂度并不完整因此需要加上O()，即：</strong></p>
<blockquote>
<p>T(n)是不是常数：</p>
<ul>
<li>是： 时间复杂度为O(1)</li>
<li>否： 时间复杂度为O(保留T(n)的最高次项并且去掉最高次项的系数)</li>
</ul>
</blockquote>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度为O(1)</span></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度为O(n)</span></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度为O(n^2)</span></span><br></pre></td></tr></table></figure>
<p><strong>如果有a重循环，时间复杂度为O(n^a)</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T(n) 为 n^2 + n</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在判断时，也以循环多的部分取时间复杂度</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(n);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可看出i=0时代码执行了n次、1：(n-1)、2：(n-2) ... n-1：2、n：1</span></span><br><span class="line"><span class="comment">// 将其相加得</span></span><br><span class="line"><span class="comment">// n + (n-1) + (n-2) + ... + 2 + 1</span></span><br><span class="line"><span class="comment">// (n + 1) * n/2</span></span><br><span class="line"><span class="comment">// 1/2 * n^2 + 1/2 * n</span></span><br><span class="line"><span class="comment">// = O(n^2)</span></span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i*=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>// T(8)  = 3 T(16) = 4<br>// 2^T(8) = 8 2^T(16) = 16<br>// 2^T(n) = n</p>
</blockquote>
<p><img src="image-20210318175253817.png" alt="image-20210318175253817"></p>
<blockquote>
<p>最后得出时间复杂度为O(logn)</p>
</blockquote>
<p>对数，需要求？的值：<br>a^? = b </p>
<p>可表示为</p>
<p><img src="%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20210318175555956.png" alt="image-20210318175555956"></p>
<p>常见时间复杂度的速度</p>
<p><img src="image-20210318175821194.png" alt="image-20210318175821194"></p>
<p><img src="image-20210318175939197.png" alt="image-20210318175939197"></p>
<p><img src="image-20210318180017029.png" alt="image-20210318180017029"></p>
<p>时间复杂度排序</p>
<p><img src="image-20210318175727074.png" alt="image-20210318175727074"></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>复杂度</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用</title>
    <url>/2021/02/24/%E5%8D%9A%E5%AE%A2/Typora/Typora%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="typora修改简单颜色样式"><a href="#typora修改简单颜色样式" class="headerlink" title="typora修改简单颜色样式"></a>typora修改简单颜色样式</h2><blockquote>
<h4 id="进入-视图-gt-开发者模式"><a href="#进入-视图-gt-开发者模式" class="headerlink" title="进入 视图 &gt; 开发者模式"></a>进入 视图 &gt; 开发者模式</h4></blockquote>
<a id="more"></a>

<p>会显示类似于浏览器的开发者模式窗口</p>
<p><img src="image-20210224100817244.png" alt="image-20210224100817244"></p>
<p>此时选择想要修改样式的内容</p>
<p><img src="image-20210224101056830.png" alt="image-20210224101056830"></p>
<p>修改完毕后右键Copy link address复制文件路径</p>
<p><img src="image-20210224101242695.png" alt="image-20210224101242695"></p>
<blockquote>
<h4 id="查找文件路径"><a href="#查找文件路径" class="headerlink" title="查找文件路径"></a>查找文件路径</h4></blockquote>
<p>  一般文件会有带盘符的完整路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">file:<span class="comment">///E:/6-17/workapp/util/Typora/resources/app//style/window.css</span></span><br></pre></td></tr></table></figure>


<p> 有的文件则以typora:开头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typora: 表示在typora安装目录中，一般为：Typora\resources\app</span></span><br><span class="line"><span class="comment">// userData 可看做style目录</span></span><br><span class="line">typora:<span class="comment">//userData\themes\github.css</span></span><br></pre></td></tr></table></figure>


<p>此时需要</p>
<p><img src="image-20210224103451712.png" alt="image-20210224103451712"></p>
<p>此时直接进入 typora://userData\themes 中</p>
<blockquote>
<h4 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h4></blockquote>
<p>根据行数及选择器名修改样式内容保存即可</p>
]]></content>
      <tags>
        <tag>博客-Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo中添加图片</title>
    <url>/2021/02/21/%E5%8D%9A%E5%AE%A2/hexo/hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>在hexo根目录下执行如下命令</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-asset-image</span><br></pre></td></tr></table></figure>


<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>打开在hexo根目录下的 _config.yml 配置文件，找到 post_asset_folder 属性，默认为 false 改为 true</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>此时再执行命令 <code>hexo n test</code> 创建新的文章，</p>
<p>在 <code>source/_posts</code> 中会生成文章 <code>test.md</code> 和同名文件夹 <code>test</code>我们将文章中所使用到的将图片资源均放在 <code>test</code> 中，这时就可以在文章中使用相对路径引用图片资源了<br> <code>[img_name](img_name.jpg)  #文章中的图片资源路径格式</code></p>
<h5 id="创建后再将生成的文件及用来存放图片的文件夹移动到文件夹中，图片依旧可以加载，可以此进行视觉分类"><a href="#创建后再将生成的文件及用来存放图片的文件夹移动到文件夹中，图片依旧可以加载，可以此进行视觉分类" class="headerlink" title="创建后再将生成的文件及用来存放图片的文件夹移动到文件夹中，图片依旧可以加载，可以此进行视觉分类"></a>创建后再将生成的文件及用来存放图片的文件夹移动到文件夹中，图片依旧可以加载，可以此进行视觉分类</h5><h5 id="首次进行图片上传可能会失败，原因未知"><a href="#首次进行图片上传可能会失败，原因未知" class="headerlink" title="首次进行图片上传可能会失败，原因未知"></a>首次进行图片上传可能会失败，原因未知</h5><p><img src="image-20210221172514240.png"></p>
]]></content>
      <tags>
        <tag>博客-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>cron表达式</title>
    <url>/2021/02/25/java/%E5%89%8D%E5%90%8E%E7%AB%AF/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>　　<strong>一、结构</strong></p>
<p>　　corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份</p>
<p>​    <a id="more"></a></p>
<p>　　<strong>二、各字段的含义</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>允许值</th>
<th>允许的特殊字符</th>
</tr>
</thead>
<tbody><tr>
<td>秒（Seconds）</td>
<td>0~59的整数</td>
<td>, - * /   四个字符</td>
</tr>
<tr>
<td>分（<em>Minutes</em>）</td>
<td>0~59的整数</td>
<td>, - * /   四个字符</td>
</tr>
<tr>
<td>小时（<em>Hours</em>）</td>
<td>0~23的整数</td>
<td>, - * /   四个字符</td>
</tr>
<tr>
<td>日期（<em>DayofMonth</em>）</td>
<td>1~31的整数（但是你需要考虑你月的天数）</td>
<td>,- * ? / L W C   八个字符</td>
</tr>
<tr>
<td>月份（<em>Month</em>）</td>
<td>1~12的整数或者 JAN-DEC</td>
<td>, - * /   四个字符</td>
</tr>
<tr>
<td>星期（<em>DayofWeek</em>）</td>
<td>1~7的整数或者 SUN-SAT （1=SUN）</td>
<td>, - * ? / L C #   八个字符</td>
</tr>
<tr>
<td>年(可选，留空)（<em>Year</em>）</td>
<td>1970~2099</td>
<td>, - * /   四个字符</td>
</tr>
</tbody></table>
<p>　　<strong>注意事项：</strong></p>
<p>　　每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：</p>
<p>　　（1）<em>：表示匹配该域的任意值。假如在Minutes域使用</em>, 即表示每分钟都会触发事件。</p>
<p>　　（2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用<em>，如果使用</em>表示不管星期几都会触发，实际上并不是这样。</p>
<p>　　（3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 </p>
<p>　　（4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. </p>
<p>　　（5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 </p>
<p>　　（6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 </p>
<p>　　（7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。</p>
<p>　　（8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 </p>
<p>　　（9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。</p>
<p>　　<strong>三、常用表达式例子</strong></p>
<p>　　（1）<strong>0 0 2 1 * ? *</strong>  表示在每月的1日的凌晨2点调整任务</p>
<p>　　（2）<strong>0 15 10 ? * MON-FRI</strong>  表示周一到周五每天上午10:15执行作业</p>
<p>　　（3）<strong>0 15 10 ? 6L 2002-2006</strong>  表示2002-2006年的每个月的最后一个星期五上午10:15执行作</p>
<p>　　（4）<strong>0 0 10,14,16 * * ?</strong>  每天上午10点，下午2点，4点 </p>
<p>　　（5）<strong>0 0/30 9-17 * * ?</strong>  朝九晚五工作时间内每半小时 </p>
<p>　　（6）<strong>0 0 12 ? * WED</strong>   表示每个星期三中午12点 </p>
<p>　　（7）<strong>0 0 12 * * ?</strong>  每天中午12点触发 </p>
<p>　　（8）<strong>0 15 10 ? * *</strong>   每天上午10:15触发 </p>
<p>　　（9）<strong>0 15 10 * * ?</strong>   每天上午10:15触发 </p>
<p>　　（10）<strong>0 15 10 * * ? *</strong>   每天上午10:15触发 </p>
<p>　　（11）<strong>0 15 10 * * ? 2005</strong>   2005年的每天上午10:15触发 </p>
<p>　　（12）<strong>0 * 14 * * ?</strong>   在每天下午2点到下午2:59期间的每1分钟触发 </p>
<p>　　（13）<strong>0 0/5 14 * * ?</strong>   在每天下午2点到下午2:55期间的每5分钟触发 </p>
<p>　　（14）<strong>0 0/5 14,18 * * ?</strong>   在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </p>
<p>　　（15）<strong>0 0-5 14 * * ?</strong>   在每天下午2点到下午2:05期间的每1分钟触发 </p>
<p>　　（16）<strong>0 10,44 14 ? 3 WED</strong>   每年三月的星期三的下午2:10和2:44触发 </p>
<p>　　（17）<strong>0 15 10 ? * MON-FRI</strong>   周一至周五的上午10:15触发 </p>
<p>　　（18）<strong>0 15 10 15 * ?</strong>   每月15日上午10:15触发 </p>
<p>　　（19）<strong>0 15 10 L * ?</strong>   每月最后一日的上午10:15触发 </p>
<p>　　（20）<strong>0 15 10 ? * 6L</strong>   每月的最后一个星期五上午10:15触发 </p>
<p>　　（21）<strong>0 15 10 ? * 6L 2002-2005</strong>  2002年至2005年的每月的最后一个星期五上午10:15触发 </p>
<p>　　（22）<strong>0 15 10 ? * 6#3</strong>  每月的第三个星期五上午10:15触发</p>
<p>　　</p>
<p>　　<strong>注：</strong></p>
<p>　　（1）有些子表达式能包含一些范围或列表</p>
<p>　　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”</p>
<p>“*”字符代表所有可能的值</p>
<p>　　因此，“<em>”在子表达式（月）里表示每个月的含义，“</em>”在子表达式（天（星期））表示星期的每一天</p>
<p>　　“/”字符用来指定数值的增量<br>　　例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟<br>在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样</p>
<p>　　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值<br>　　当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”</p>
<p>　　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写<br>　　但是它在两个子表达式里的含义是不同的。<br>　　在天（月）子表达式中，“L”表示一个月的最后一天<br>　　在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT</p>
<p>　　如果在“L”前有具体的内容，它就具有其他的含义了</p>
<p>　　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五<br>　　注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>
]]></content>
      <tags>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用</title>
    <url>/2021/02/21/%E5%8D%9A%E5%AE%A2/hexo/hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="可以在md文章中添加-lt-more-gt-标签达成折叠文章的目的"><a href="#可以在md文章中添加-lt-more-gt-标签达成折叠文章的目的" class="headerlink" title="可以在md文章中添加&lt;!--more--&gt;标签达成折叠文章的目的"></a>可以在md文章中添加<code>&lt;!--more--&gt;</code>标签达成折叠文章的目的</h3><p>​    标签不能放置在文章开头，否则会被无视</p>
<a id="more"></a>



<h3 id="source-posts中的文件使用文件夹划分并不会达成分级的效果"><a href="#source-posts中的文件使用文件夹划分并不会达成分级的效果" class="headerlink" title="\source_posts中的文件使用文件夹划分并不会达成分级的效果"></a>\source_posts中的文件使用文件夹划分并不会达成分级的效果</h3><p>但可以依靠分包进行视觉上的区分</p>
<h3 id="可以不用添加标号，上传后文章目录会自动添加"><a href="#可以不用添加标号，上传后文章目录会自动添加" class="headerlink" title="可以不用添加标号，上传后文章目录会自动添加"></a>可以不用添加标号，上传后文章目录会自动添加</h3><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><h3 id="md头的作用"><a href="#md头的作用" class="headerlink" title="md头的作用"></a>md头的作用</h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。支援多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分类  创建分类页 hexo new page categories</span></span><br><span class="line">categories: hexo</span><br><span class="line"><span class="comment">// 标签  创建标签页 hexo new page tags</span></span><br><span class="line">type: tags </span><br></pre></td></tr></table></figure>


<h3 id="hexo页面文章使用时间排序，最早的文章会放到最下边，"><a href="#hexo页面文章使用时间排序，最早的文章会放到最下边，" class="headerlink" title="hexo页面文章使用时间排序，最早的文章会放到最下边，"></a>hexo页面文章使用时间排序，最早的文章会放到最下边，</h3><p>所以可以通过修改头部的时间来对文章进行排序</p>
<h3 id="文件名并没有用，页面中最大的标题为文件头中title后的内容"><a href="#文件名并没有用，页面中最大的标题为文件头中title后的内容" class="headerlink" title="文件名并没有用，页面中最大的标题为文件头中title后的内容"></a>文件名并没有用，页面中最大的标题为文件头中title后的内容</h3><h3 id="将Hexo设置成中文"><a href="#将Hexo设置成中文" class="headerlink" title="将Hexo设置成中文"></a>将Hexo设置成中文</h3><p>很多文档和博客都将language设置成zh-Hans，结果登录个人站一直不能显示中文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: Welcome</span><br><span class="line">description: you can enjoy a grander sight，if you climb to a greater height</span><br><span class="line">keywords:</span><br><span class="line">author: RedeeMi</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: </span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<p>找到next文件夹下的languages文件夹，看到zh-CN.yml，所以选择把languages设为zh-CN<br><img src="https://img-blog.csdnimg.cn/20201216200852675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyMzE2OTEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: RedeeMi的个人站</span><br><span class="line">subtitle: Welcome</span><br><span class="line">description: you can enjoy a grander sight，if you climb to a greater height</span><br><span class="line">keywords:</span><br><span class="line">author: RedeeMi</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: </span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<p>如果还没有显示为中文，clean后再登录即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>


<h2 id="Hexo-next主题添加"><a href="#Hexo-next主题添加" class="headerlink" title="Hexo next主题添加"></a>Hexo next主题添加</h2><h3 id="Hexo-next主题添加访问统计"><a href="#Hexo-next主题添加访问统计" class="headerlink" title="Hexo next主题添加访问统计"></a>Hexo next主题添加访问统计</h3><h5 id="注：不同主题添加统计的方式不同"><a href="#注：不同主题添加统计的方式不同" class="headerlink" title="注：不同主题添加统计的方式不同"></a>注：不同主题添加统计的方式不同</h5><h4 id="1-打开next主题配置文件-themes-next-config-yml，搜索找到busuanzi-count，把enable设置为true"><a href="#1-打开next主题配置文件-themes-next-config-yml，搜索找到busuanzi-count，把enable设置为true" class="headerlink" title="1. 打开next主题配置文件\themes\next\_config.yml，搜索找到busuanzi_count，把enable设置为true"></a>1. 打开next主题配置文件\themes\next\_config.yml，搜索找到<strong>busuanzi_count</strong>，把enable设置为true</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.#展示访问数</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  total_visitors: true   #统计访客数</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true    #统计访问数</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true   #统计文章阅读数</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>


<h4 id="2-同样是在next主题配置文件-themes-next-config-yml下，搜索footer，在它底下添加counter，设值为true"><a href="#2-同样是在next主题配置文件-themes-next-config-yml下，搜索footer，在它底下添加counter，设值为true" class="headerlink" title="2. 同样是在next主题配置文件\themes\next\_config.yml下，搜索footer，在它底下添加counter，设值为true"></a>2. 同样是在next主题配置文件\themes\next\_config.yml下，搜索<strong>footer</strong>，在它底下添加counter，设值为true</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 统计  </span><br><span class="line">counter: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>


<h4 id="3-来到themes-next-layout-partials，找到footer-swig文件，打开编辑，在底下添加代码"><a href="#3-来到themes-next-layout-partials，找到footer-swig文件，打开编辑，在底下添加代码" class="headerlink" title="3. 来到themes\next\layout\_partials，找到footer.swig文件，打开编辑，在底下添加代码"></a>3. 来到themes\next\layout\_partials，找到<strong>footer.swig</strong>文件，打开编辑，在底下添加代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.footer.counter %&#125;</span><br><span class="line">    &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Hexo-next主题添加搜索"><a href="#Hexo-next主题添加搜索" class="headerlink" title="Hexo next主题添加搜索"></a>Hexo next主题添加搜索</h3><h4 id="1-安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令："><a href="#1-安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：" class="headerlink" title="1. 安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令："></a>1. 安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>


<h4 id="2-全局配置文件-config-yml，新增如下内容："><a href="#2-全局配置文件-config-yml，新增如下内容：" class="headerlink" title="2.全局配置文件_config.yml，新增如下内容："></a>2.全局配置文件_config.yml，新增如下内容：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 添加搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure>


<h4 id="3-hexo主题配置文件（-themes-next-config-yml），修改local-search的enable为true："><a href="#3-hexo主题配置文件（-themes-next-config-yml），修改local-search的enable为true：" class="headerlink" title="3.hexo主题配置文件（\themes\next\_config.yml），修改local_search的enable为true："></a>3.hexo主题配置文件（\themes\next\_config.yml），修改local_search的enable为true：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h3 id="Hexo-NexT主题下开启其他菜单项，比如分类、标签、关于"><a href="#Hexo-NexT主题下开启其他菜单项，比如分类、标签、关于" class="headerlink" title="Hexo NexT主题下开启其他菜单项，比如分类、标签、关于"></a>Hexo NexT主题下开启其他菜单项，比如分类、标签、关于</h3><p>首先打开主题下的配置文件_config.yml，然后搜索menu找到如下配置项，将about、tags、categories前的#号去掉，就开启了关于、标签和分类标签，当然还有其他菜单项也可以开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Menu Settings</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When running the site <span class="keyword">in</span> a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Usage: `Key: /link/ || icon`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Key is the name of menu item. If the translation <span class="keyword">for</span> this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Value before `||` delimiter is the target link.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Value after `||` delimiter is the name of FontAwesome icon. If icon (with or without delimiter) is not specified, question icon will be loaded.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> External url should start with http:// or https://</span></span><br><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line"><span class="meta">  #</span><span class="bash">schedule: /schedule/ || calendar</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<p>重新生成部署后，可以看到新增的菜单项，但是单击后会报如下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cannot GET /about/</span><br><span class="line">Cannot GET /tags/</span><br><span class="line">Cannot GET /categories/</span><br></pre></td></tr></table></figure>

<p>这是因为你还需运行如下命令新建相关页面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>


<p>运行结果如下，会再source文件下创建about、tags、categories文件夹，每个文件夹下还会创建一个index.md文件表示关于、标签页分类页面，编辑这三个MarkDown文件可以自定义这三个页面的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\hexo\blog&gt;hexo new page &quot;about&quot;</span><br><span class="line">INFO  Created: D:\hexo\blog\source\about\index.md</span><br><span class="line"></span><br><span class="line">D:\hexo\blog&gt;hexo new page &quot;tags&quot;</span><br><span class="line">INFO  Created: D:\hexo\blog\source\tags\index.md</span><br><span class="line"></span><br><span class="line">D:\hexo\blog&gt;hexo new page &quot;categories&quot;</span><br><span class="line">INFO  Created: D:\hexo\blog\source\categories\index.md</span><br></pre></td></tr></table></figure>


<p>还差最后一步，打开各页面对应的index.md文件，编辑如下内容，title和date是默认生成的，增加type即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">title: about</span><br><span class="line">date: 2019-06-25 19:16:17</span><br><span class="line"></span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">title: about</span><br><span class="line">date: 2019-06-25 19:16:17</span><br><span class="line"></span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">title: about</span><br><span class="line">date: 2019-06-25 19:16:17</span><br><span class="line"></span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Hexo-分类文章进行分级"><a href="#Hexo-分类文章进行分级" class="headerlink" title="Hexo 分类文章进行分级"></a>Hexo 分类文章进行分级</h3><p>添加分类页面成功后</p>
<p>文章添加<code>categories: 分类1</code>即可添加分类</p>
<p>添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">categories: </span><br><span class="line">- 笔记</span><br><span class="line">- javascript</span><br><span class="line">- 面向对象编程</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">category: </span><br><span class="line">- 笔记</span><br><span class="line">- javascript</span><br><span class="line">- 面向对象编程</span><br></pre></td></tr></table></figure>
<p>即可进行分类分级</p>
]]></content>
      <tags>
        <tag>博客-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo指令</title>
    <url>/2021/02/21/%E5%8D%9A%E5%AE%A2/hexo/hexo%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>​    </p>
<h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><p>​    hexo new “文章名称”</p>
<a id="more"></a>

<p>​    或</p>
<p>​    hexo n “文章名称”</p>
<h3 id="清理页面"><a href="#清理页面" class="headerlink" title="清理页面"></a>清理页面</h3><p>hexo clean</p>
<h3 id="生成页面-generate"><a href="#生成页面-generate" class="headerlink" title="生成页面 (generate)"></a>生成页面 (generate)</h3><p>​    hexo g </p>
<h3 id="本地预览页面（show）"><a href="#本地预览页面（show）" class="headerlink" title="本地预览页面（show）"></a>本地预览页面（show）</h3><p>​    hexo s </p>
<h3 id="部署发布-deploy"><a href="#部署发布-deploy" class="headerlink" title="部署发布 (deploy)"></a>部署发布 (deploy)</h3><p>​    hexo d</p>
<h3 id="生成标签页面-页面文章头部需要添加-type-tags"><a href="#生成标签页面-页面文章头部需要添加-type-tags" class="headerlink" title="生成标签页面  页面文章头部需要添加  type: tags"></a>生成标签页面  页面文章头部需要添加  type: tags</h3><h3 id="文章通过添加（tags-标签）来添加标签"><a href="#文章通过添加（tags-标签）来添加标签" class="headerlink" title="文章通过添加（tags: 标签）来添加标签"></a>文章通过添加（tags: 标签）来添加标签</h3><p>​    hexo new page 标签</p>
<h3 id="生成分类页面-头部需要添加-type-categoriese"><a href="#生成分类页面-头部需要添加-type-categoriese" class="headerlink" title="生成分类页面  头部需要添加  type: categoriese"></a>生成分类页面  头部需要添加  type: categoriese</h3><h3 id="文章通过添加（categoriese-分类）来添加分类"><a href="#文章通过添加（categoriese-分类）来添加分类" class="headerlink" title="文章通过添加（categoriese: 分类）来添加分类"></a>文章通过添加（categoriese: 分类）来添加分类</h3><p>​    hexo new page 分类</p>
]]></content>
      <tags>
        <tag>博客-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo添加分类及标签</title>
    <url>/2021/02/21/%E5%8D%9A%E5%AE%A2/hexo/hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="Hexo-添加分类及标签"><a href="#Hexo-添加分类及标签" class="headerlink" title="Hexo 添加分类及标签"></a>Hexo 添加分类及标签</h1><p>生成的新文件夹都在source下也就是和放文章的文件夹一块 以下所有命令都是在博客文件目录下执行</p>
<a id="more"></a>

<h4 id="1-创建“分类”选项"><a href="#1-创建“分类”选项" class="headerlink" title="1. 创建“分类”选项"></a>1. 创建“分类”选项</h4><p>生成“分类”页并添加tpye属性,进入博客目录。执行下方命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-04-22 14:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加type: “categories”到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-04-24 15:30:30</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<p>给文章添加“categories”属性</p>
<p>打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
<h4 id="2-创建“标签”选项"><a href="#2-创建“标签”选项" class="headerlink" title="2. 创建“标签”选项"></a>2. 创建“标签”选项</h4><p>生成“标签”页并添加tpye属性，<code>页面进入标签页默认找tags目录</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-04-22 14:22:08</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-04-24 15:40:24</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<p>给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2019-04-24 15:40:24</span><br><span class="line">categories: - Hexo</span><br><span class="line">tags: - 博客</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用</title>
    <url>/2021/03/05/%E6%8A%80%E6%9C%AF/Docker/Docker%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h2><a id="more"></a>

<blockquote>
<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示docker版本信息</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示docker更加详细的信息</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 帮助命令  或者docker <span class="built_in">help</span></span></span><br><span class="line">docker 命令 --help</span><br></pre></td></tr></table></figure>


<p>官网命令文档</p>
<p>网址：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p>
<p><img src="image-20210305181538559.png" alt="image-20210305181538559"></p>
<blockquote>
<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3></blockquote>
<blockquote>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3></blockquote>
]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装</title>
    <url>/2021/03/02/%E6%8A%80%E6%9C%AF/Docker/Docker%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><a id="more"></a>

<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=793314303,480081697&fm=26&gp=0.jpg" alt="img"></p>
<p><strong>镜像（image）：</strong></p>
<p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像 ==&gt; run ==&gt; tomcat1容器（提供服务器），通过这个镜像可以创建多个容器（最终服务或者项目运行就是在容器中的）</p>
<p><strong>容器（container）：</strong></p>
<p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的。</p>
<p>可以将容器理解为一个简易的Linux系统</p>
<p>基本命令：启动、停止、删除</p>
<p><strong>仓库（repository）：</strong></p>
<p>仓库就是存放镜像的地方</p>
<p>仓库分为共有仓库和私有仓库</p>
<p>Docker Hub (默认)</p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote>
<h3 id="卸载旧的版本"><a href="#卸载旧的版本" class="headerlink" title="卸载旧的版本"></a>卸载旧的版本</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">            docker-client \</span><br><span class="line">            docker-client-latest \</span><br><span class="line">            docker-common \</span><br><span class="line">            docker-latest \</span><br><span class="line">            docker-latest-logrotate \</span><br><span class="line">            docker-logrotate \</span><br><span class="line">            docker-engine</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="需要的安装包"><a href="#需要的安装包" class="headerlink" title="需要的安装包"></a>需要的安装包</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="设置镜像的仓库"><a href="#设置镜像的仓库" class="headerlink" title="设置镜像的仓库"></a>设置镜像的仓库</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo   # 国外镜像仓库</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 阿里镜像仓库</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">	https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>


<blockquote>
<p>更新yum软件包索引</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line">// centos8可能需要使用</span><br><span class="line">yum makecache timer</span><br></pre></td></tr></table></figure>




<blockquote>
<h3 id="安装docker相关的内容"><a href="#安装docker相关的内容" class="headerlink" title="安装docker相关的内容"></a>安装docker相关的内容</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker-ce 社区版本  ee企业版</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>


<blockquote>
<p>安装报错</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: </span><br><span class="line"> Problem: problem with installed package buildah-1.15.1-2.module_el8.3.0+475+c50ce30b.x86_64</span><br><span class="line"></span><br><span class="line">  - package buildah-1.15.1-2.module_el8.3.0+475+c50ce30b.x86_64 requires runc &gt;= 1.0.0-26, but none of the providers can be installed</span><br><span class="line">  - package buildah-1.16.7-4.module_el8.3.0+699+d61d9c41.x86_64 requires runc &gt;= 1.0.0-26, but none of the providers can be installed</span><br><span class="line">  - package containerd.io-1.4.3-3.1.el8.x86_64 conflicts with runc provided by runc-1.0.0-68.rc92.module_el8.3.0+475+c50ce30b.x86_64</span><br><span class="line">  - package containerd.io-1.4.3-3.1.el8.x86_64 obsoletes runc provided by runc-1.0.0-68.rc92.module_el8.3.0+475+c50ce30b.x86_64</span><br><span class="line">  - package containerd.io-1.4.3-3.1.el8.x86_64 conflicts with runc provided by runc-1.0.0-70.rc92.module_el8.3.0+699+d61d9c41.x86_64</span><br><span class="line">  - package containerd.io-1.4.3-3.1.el8.x86_64 obsoletes runc provided by runc-1.0.0-70.rc92.module_el8.3.0+699+d61d9c41.x86_64</span><br><span class="line">  - cannot install the best candidate for the job</span><br><span class="line">  - package runc-1.0.0-56.rc5.dev.git2abd837.module_el8.3.0+569+1bada2e4.x86_64 is filtered out by modular filtering</span><br><span class="line">  - package runc-1.0.0-64.rc10.module_el8.3.0+479+69e2ae26.x86_64 is filtered out by modular filtering</span><br><span class="line">    (try to add &#x27;--allowerasing&#x27; to command line to replace conflicting packages or &#x27;--skip-broken&#x27; to skip uninstallable packages or &#x27;--nobest&#x27; to use not only best candidate packages)</span><br></pre></td></tr></table></figure>


<p>解决方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看是否安装podman</span></span><br><span class="line">rpm -q podman</span><br><span class="line">podman-1.4.2-5.module_el8.1.0+237+63e26edc.x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除Podman</span></span><br><span class="line">dnf remove podman</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 未解决时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入下面的命令继续安装：</span></span><br><span class="line">yum install --allowerasing docker-ce</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker是否启动成功(查看版本信息)</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p><img src="image-20210304190851060.png" alt="image-20210304190851060"></p>
<blockquote>
<h3 id="运行hello-world"><a href="#运行hello-world" class="headerlink" title="运行hello-world"></a>运行hello-world</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker run hello-world</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 提示未寻找到hello-world镜像</span></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 执行pull远程拉取官方library/hello-world镜像</span></span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示拉取成功</span></span><br><span class="line">0e03bdcc26d7: Pull complete </span><br><span class="line">Digest: sha256:7e02330c713f93b1d3e4c5003350d0dbe215ca269dd1d84a4abc577908344b30</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行hello-world表示docker安装成功</span></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="查看下载的hello-world镜像在不在"><a href="#查看下载的hello-world镜像在不在" class="headerlink" title="查看下载的hello-world镜像在不在"></a>查看下载的hello-world镜像在不在</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   14 months ago   13.3kB</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h3><p>docker默认工作路径： /var/lib/docker</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载docker</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件目录</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line">rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>


<h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><ol>
<li><p>页面：<a href="https://homenew.console.aliyun.com/">https://homenew.console.aliyun.com</a></p>
<p><img src="image-20210305165612518.png" alt="image-20210305165612518"></p>
</li>
<li><p>找到镜像加速地址</p>
</li>
</ol>
<p><img src="image-20210305165715379.png" alt="image-20210305165715379"></p>
<pre><code>3. 配置使用</code></pre>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写配置文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://lz60pcen.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>


<h2 id="回顾HelloWorld的流程"><a href="#回顾HelloWorld的流程" class="headerlink" title="回顾HelloWorld的流程"></a>回顾HelloWorld的流程</h2><p><img src="image-20210305170945074.png" alt="qq登录的https://www.processon.com"></p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><h4 id="Docker是怎么工作的"><a href="#Docker是怎么工作的" class="headerlink" title="Docker是怎么工作的"></a>Docker是怎么工作的</h4><p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问</p>
<p><img src="image-20210305173655204.png" alt="image-20210305173655204"></p>
<p>Linux服务器中可能存在多个客户端，客户端连接到后台的守护进程，通过守护进程操作docker容器中的资源，容器与虚拟机之间互相隔离，容器相当于一个小的Linux虚拟机，在其中运行的服务相对于整个linux服务器是独立的，如localhost:8080，这个8080在外界是无法访问的，同理容器与容器之间也是相互隔离的，若要在linux服务器中访问容器中的内容需要做一个联通</p>
<h4 id="Docker为什么比虚拟机快"><a href="#Docker为什么比虚拟机快" class="headerlink" title="Docker为什么比虚拟机快"></a>Docker为什么比虚拟机快</h4><ol>
<li>docker有着比虚拟机更少的抽象层</li>
<li>docker利用的是宿主机的内核，vm需要的是Guest OS</li>
</ol>
<p><img src="image-20210305173901308.png" alt="image-20210305173901308"></p>
<p>所以说，新建一个容器的时候，docker不需要像一个虚拟机一样重新加载一个操作系统内核，虚拟机是加载Guest OS，分钟级别的，而docker是利用宿主机的操作系统，省略了这个复杂的过程，为秒级。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker概念</title>
    <url>/2021/03/02/%E6%8A%80%E6%9C%AF/Docker/Docker%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h2><a id="more"></a>

<p>入门</p>
<ul>
<li><p>Docker概述</p>
</li>
<li><p>Docker安装</p>
</li>
<li><p>Docker命令</p>
<ul>
<li>镜像</li>
<li>容器</li>
<li>操作</li>
<li>……</li>
</ul>
</li>
<li><p>==Docker镜像==</p>
</li>
<li><p>==容器数据卷==</p>
</li>
</ul>
<p>构建镜像</p>
<ul>
<li>DockerFile</li>
</ul>
<p>基于网络</p>
<ul>
<li>Docker网络原理</li>
<li>IDEA整合Docker</li>
</ul>
<p>集群</p>
<ul>
<li>Docker Compose</li>
<li>Docker Swarm</li>
</ul>
<p>持续编程持续部署</p>
<ul>
<li>CI/CD Jenkins</li>
</ul>
<h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><blockquote>
<h3 id="Docker为什么出现"><a href="#Docker为什么出现" class="headerlink" title="Docker为什么出现"></a>Docker为什么出现</h3></blockquote>
<ol>
<li>一款产品：开发 – 上线，应用环境，应用配置</li>
<li>开发 – 运维。问题：我在我的电脑上可以运行！版本更新，导致服务不可用！对于运维来说，考验就十分大</li>
<li>环境配置十分麻烦，每台机器都要部署环境(集群Redis、ES、Hadoop……)，费时费力</li>
</ol>
<p>​    发布项目时，将项目带着环境一起发布(jar + (Redis + Mysql + jdk + ES))，项目带上环境安装打包！</p>
<p>​    </p>
<p>​    java —- apk —- 发布（应用商店） —- 客户使用apk —- 安装即可使用</p>
<p>​    java开发 —- jar + 环境 —- 打包项目带上环境 —- Docker仓库（类似于商店）—- 客户可直接下载发布的镜像 —- 直接运行即可</p>
<p>​    Docker的思想来自于集装箱</p>
<p>​    <img src="image-20210302155750048.png" alt="image-20210302155750048"></p>
<p>​    </p>
<p>​    多个应用使用的都是同一套环境可能存在端口冲突等问题</p>
<p>​    ==隔离==：Docker核心思想，打包装箱，每个箱子都是互相隔离的，即每个应用使用各自的环境</p>
<h2 id="Docker资源"><a href="#Docker资源" class="headerlink" title="Docker资源"></a>Docker资源</h2><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p><img src="image-20210302163351910.png" alt="image-20210302163351910"></p>
<p>官方文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p>
<p>Docker hub(类似于github的仓库)：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h2 id="Docker作用"><a href="#Docker作用" class="headerlink" title="Docker作用"></a>Docker作用</h2><blockquote>
<p>在容器技术出现前，都是使用的虚拟机技术，虚拟机和Docker的容器技术都是==虚拟化技术==</p>
</blockquote>
<p>虚拟机技术：在windows中装一个VMware，通过这个软件虚拟出来一台或多台电脑(特点：笨重，与真实的电脑是一样的)</p>
<p>容器技术：隔离，镜像，十分小巧，仅需运行镜像即可</p>
<blockquote>
<p>虚拟机技术</p>
</blockquote>
<p><img src="image-20210302172210980.png" alt="image-20210302172210980"></p>
<p>在windows中装一个VMware，通过这个软件虚拟出来一台或多台电脑(特点：笨重，与真实的电脑是一样的)</p>
<p>虚拟机技术缺点：</p>
<ol>
<li>资源占用十分多</li>
<li>冗余步骤多</li>
<li>启动慢</li>
</ol>
<blockquote>
<p>容器化技术</p>
</blockquote>
<p>==容器化技术不是模拟一个完整的操作系统==</p>
<p> <img src="image-20210302172812341.png" alt="image-20210302172812341">    </p>
<p>与虚拟机技术比较：</p>
<ul>
<li>传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在宿主机的内核中，容器是没有自己的内核的，也没有虚拟硬件，所以就轻便了</li>
<li>每个容器之间互相隔离，每个容器内都有一个属于自己的文件系统，互不影响。</li>
</ul>
<blockquote>
<p>DevOps（开发、运维）</p>
</blockquote>
<p><strong>应用更快速的交付和部署</strong></p>
<p>传统：一堆帮助文档，安装程序</p>
<p>Docker：打包镜像发布测试，一键运行</p>
<p><strong>更便捷的升级和扩缩容</strong></p>
<p>项目打包成一个镜像后，若需要从服务器A 扩展到 服务器B，仅需要在服务器B上运行镜像文件即可</p>
<p><strong>更简单的系统运维</strong></p>
<p>在容器化之后，开发与测试环境都是高度一致的</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例，服务器性能可以被压榨极致。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm介绍</title>
    <url>/2021/03/08/%E6%8A%80%E6%9C%AF/JVM/jvm%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h2><a id="more"></a>

<ul>
<li>对<code>JVM</code>的理解，<code>java8</code>虚拟机和之前的变化更新</li>
<li>什么是<code>OOM</code>，什么是栈溢出<code>StackOverFlowError</code>？怎么分析？</li>
<li><code>JVM</code>常用的调优参数</li>
<li>内存快照如何抓取，怎么分析<code>Dump</code>文件</li>
<li>谈谈<code>JVM</code>中，类加载器的认识</li>
</ul>
<h3 id="JVM位置"><a href="#JVM位置" class="headerlink" title="JVM位置"></a>JVM位置</h3><p>java虚拟机 位于操作系统上</p>
<p><img src="image-20210309093518232.png" alt="image-20210309093518232"></p>
<h3 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h3><p><img src="image-20210310152333062.png" alt="image-20210310152333062"></p>
<p>​    </p>
<ol>
<li><p>垃圾集中区域： 主要是在堆里面，方法区占少量</p>
</li>
<li><p>所谓的<code>JVM调优</code>其实99%都是在<code>方法区及堆</code>中，而其中的99%则是在<code>堆</code>中</p>
</li>
<li><p>栈中绝对不能有垃圾，栈中的东西用完就弹出去了，栈中有垃圾代表程序崩了，Main方法首先进栈，其余方法之后入栈，执行万一个弹出一个，若栈中有垃圾则影响方法弹出</p>
</li>
<li><p>方法区是一个特殊的堆</p>
</li>
</ol>
<p>​    </p>
<p>​    </p>
<ol>
<li>类加载器</li>
<li>双亲委派机制</li>
<li>沙箱安全机制</li>
<li>Native</li>
<li>PC寄存器</li>
<li>方法区</li>
<li>堆、栈</li>
<li>三种JVM</li>
<li>新生区、老年区</li>
<li>永久区</li>
<li>堆内存调优</li>
<li>GC<ol>
<li>常用算法</li>
</ol>
</li>
<li>JMM</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2021/02/23/%E6%8A%80%E6%9C%AF/git/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="git项目搭建"><a href="#git项目搭建" class="headerlink" title="git项目搭建"></a>git项目搭建</h2><h3 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h3><a id="more"></a>

<p><img src="image-liucheng.png"></p>
<h3 id="本地搭建仓库"><a href="#本地搭建仓库" class="headerlink" title="本地搭建仓库"></a>本地搭建仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>提示初始化一个空的git库在<code>G:/test/test/.git/</code></p>
<p><img src="image-20210224090517320.png" alt="image-20210224090517320"></p>
<p>此时运行命令的位置会有</p>
<p><img src="image-20210224090651065.png" alt="image-20210224090651065"></p>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 克隆整个项目及其整个代码历史(版本信息)</span><br><span class="line"># https:<span class="operator">/</span><span class="operator">/</span>gitee.com<span class="operator">/</span>kuangstudy<span class="operator">/</span>openclass.git</span><br><span class="line">git clone [url]</span><br></pre></td></tr></table></figure>


<h2 id="git文件操作"><a href="#git文件操作" class="headerlink" title="git文件操作"></a>git文件操作</h2><blockquote>
<h3 id="文件4种状态"><a href="#文件4种状态" class="headerlink" title="文件4种状态"></a>文件4种状态</h3></blockquote>
<ul>
<li><strong>Untracked</strong>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为<code>Staged</code></li>
<li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为<code>Modified</code>. 如果使用<code>git rm</code>移出版本库, 则成为<code>Untracked</code>文件</li>
<li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过<code>git add</code>可进入暂存<code>staged</code>状态, 使用<code>git checkout</code> 则丢弃修改过, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改</li>
<li><strong>Staged</strong>: 暂存状态. 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code></li>
</ul>
<blockquote>
<h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line"># 提交所有文件到暂存区  </span><br><span class="line">git add . </span><br><span class="line">    </span><br><span class="line"># 提交暂存区的内容到本地仓库</span><br><span class="line">git commit -m <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h4 id="使用该命令查看本地新搭建的项目时，显示内容为："><a href="#使用该命令查看本地新搭建的项目时，显示内容为：" class="headerlink" title="使用该命令查看本地新搭建的项目时，显示内容为："></a>使用该命令查看本地新搭建的项目时，显示内容为：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前在master分支</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前未进行提交</span></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前无任何内容需要提交</span></span><br><span class="line"><span class="function">nothing to <span class="title">commit</span> <span class="params">(create/copy files and use <span class="string">&quot;git add&quot;</span> to track)</span></span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<h4 id="新建文件hello-txt-再使用该命令查看，显示内容为："><a href="#新建文件hello-txt-再使用该命令查看，显示内容为：" class="headerlink" title="新建文件hello.txt 再使用该命令查看，显示内容为："></a>新建文件hello.txt 再使用该命令查看，显示内容为：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示未跟踪的文件</span></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未添加任何提交但是目前有未跟踪的文件</span></span><br><span class="line"><span class="function">nothing added to commit but untracked files <span class="title">present</span> <span class="params">(use <span class="string">&quot;git add&quot;</span> to track)</span></span></span><br></pre></td></tr></table></figure>


<h4 id="git-add-（提交所有文件到暂存区）"><a href="#git-add-（提交所有文件到暂存区）" class="headerlink" title="git add . （提交所有文件到暂存区）"></a>git add . （提交所有文件到暂存区）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要提交的更改</span></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">		<span class="comment">// 提示有新文件  hello.txt</span></span><br><span class="line">        <span class="keyword">new</span> file:   hello.txt</span><br></pre></td></tr></table></figure>


<h4 id="git-commit-m-（提交暂存区的内容到本地仓库）"><a href="#git-commit-m-（提交暂存区的内容到本地仓库）" class="headerlink" title="git commit -m （提交暂存区的内容到本地仓库）"></a>git commit -m （提交暂存区的内容到本地仓库）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有东西需要提交，工作树是干净的</span></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>


<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中,比如数据库文件,临时文件,设计文件等<br>在主目录下建立”.gitignore”文件,此文件有如下规则: </p>
<ol>
<li>忽略文件中的空行或以井号( # )开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如:星号(* )代表任意多个字符,问号( ? )代表-个字符,方括号( [abc] )代表可选字符范围,<br>大括号( string1，string2，…. )代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号(!) , 表示例外规则,将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符 (/) ,表示要忽略的文件在此目录下,而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符(1) , 表示要忽略的是此目录下该名称的子目录,而非文件(默认文件或目录都忽略)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt		#忽略所有. txt结尾的文件</span><br><span class="line">!lib.txt	#但lib.txt除外</span><br><span class="line">/temp 		#仅忽路项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/		#忽略bui1d/目录下的所有文件</span><br><span class="line">doc<span class="comment">/*.txt	#忽略 doc/notes.txt 但不包括doc/server/arch.txt</span></span><br></pre></td></tr></table></figure>


<h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><blockquote>
<h3 id="github-是有墙的，比较慢，在国内的话一般使用-gitee-，公司中有时候会搭建自己的-gitlib-服务器"><a href="#github-是有墙的，比较慢，在国内的话一般使用-gitee-，公司中有时候会搭建自己的-gitlib-服务器" class="headerlink" title="==github==是有墙的，比较慢，在国内的话一般使用==gitee==，公司中有时候会搭建自己的==gitlib==服务器"></a>==github==是有墙的，比较慢，在国内的话一般使用==gitee==，公司中有时候会搭建自己的==gitlib==服务器</h3></blockquote>
<p>设置本机绑定SSH公钥，实现免密登录</p>
<ol>
<li>位于<code>C:\Users\Administrator\.ssh</code>目录下</li>
</ol>
<p><img src="image-20210226143025211.png" alt="image-20210226143025211"></p>
<ol start="2">
<li>生成公钥</li>
</ol>
<p>ssh-keygen -t rsa</p>
<ol start="3">
<li>生成后产生两个文件，<code>以pub结尾的为公钥，另外一个为私钥</code></li>
</ol>
<p><img src="image-20210226143143961.png" alt="image-20210226143143961"></p>
<ol start="4">
<li>将公钥粘如码云 设置 -&gt; 安全设置 -&gt; SSH公钥</li>
</ol>
<h2 id="idea集成git"><a href="#idea集成git" class="headerlink" title="idea集成git"></a>idea集成git</h2><blockquote>
<h3 id="新项目中集成git"><a href="#新项目中集成git" class="headerlink" title="新项目中集成git"></a>新项目中集成git</h3></blockquote>
<ol>
<li><p>在码云中创建项目并拉到本地</p>
</li>
<li><p>新建项目</p>
</li>
<li><p>将码云中拉取得项目的内容全部复制到新建的项目中</p>
<p><img src="image-20210226165218143.png" alt="image-20210226165218143"></p>
</li>
</ol>
<blockquote>
<h3 id="提交代码到远程"><a href="#提交代码到远程" class="headerlink" title="提交代码到远程"></a>提交代码到远程</h3></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;修改&quot;</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交到远程  </span></span><br><span class="line"><span class="comment">// 提交到指定分支： git push origin master</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>


<h2 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h2><p>多个分支并行执行(不重合)，代码就不冲突，也就是同时存在多个版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line">    </span><br><span class="line"># 新建分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line">    </span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">git merge [branch]</span><br><span class="line">    </span><br><span class="line"># 删除分支</span><br><span class="line">git branch -d [branch]</span><br><span class="line">    </span><br><span class="line"># 删除远程分支</span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>


<p>==master主分支应该非常稳定,用来发布新版本, 一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作,工作完后,比如: 要发布,或者说dev分支代码稳定后可以合并到主分支master上来。==</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch及Head安装</title>
    <url>/2021/03/17/%E6%8A%80%E6%9C%AF/ELK%20stack/1.%20Elasticsearch%E5%8F%8AHead%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><a id="more"></a>

<ol>
<li>config 文件夹下的 elasticsearch.yml 文件中的network.host可设置允许访问的网络</li>
</ol>
<ol start="2">
<li><p>启动报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决：在/etc/security/limits.conf文件中添加，(前边的*必须存在)</span> </span><br><span class="line">* soft nofile 65536 </span><br><span class="line">* hard nofile 131072 </span><br><span class="line">* soft nproc 2048 </span><br><span class="line">* hard nproc 4096 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2]: max number of threads [1024] for user [elsearch] is too low, increase to at least [4096] </span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决：修改/etc/security/limits.d/90-nproc.conf</span> </span><br><span class="line">soft nproc 1024 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 为</span> </span><br><span class="line">soft nproc 4096 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[3]: system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk </span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决： config文件夹中 elasticsearch.yml 文件最后边添加</span> </span><br><span class="line">bootstrap.system_call_filter: false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[4]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured </span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决： config文件夹中 elasticsearch.yml 文件</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置以下三者，最少其一</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">[discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes]</span> </span><br><span class="line">cluster.initial_master_nodes: [&quot;node-1&quot;] # 这里的node-1为node.name配置的值，同时需要放开node.name</span><br></pre></td></tr></table></figure>


</li>
</ol>
<blockquote>
<p> 最好添加：</p>
<p>indices.fielddata.cache.size:  20%</p>
<p>防止缓存满却未及时清理导致报错</p>
<p>修改完后最好使用exit退出登录，然后重新登录</p>
</blockquote>
<p>其余报错解决方法：        <a href="https://www.cnblogs.com/zhi-leaf/p/8484337.html">https://www.cnblogs.com/zhi-leaf/p/8484337.html</a></p>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Elasticsearch 是一个分布式的开源搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。Elasticsearch 在 Apache Lucene 的基础上开发而成，由 Elasticsearch N.V.（即现在的 Elastic）于 2010 年首次发布。Elasticsearch 以其简单的 REST 风格 API、分布式特性、速度和可扩展性而闻名，是 Elastic Stack 的核心组件；Elastic Stack 是适用于数据采集、充实、存储、分析和可视化的一组开源工具。人们通常将 Elastic Stack 称为 ELK Stack（代指 Elasticsearch、Logstash 和 Kibana），目前 Elastic Stack 包括一系列丰富的轻量型数据采集代理，这些代理统称为 Beats，可用来向 Elasticsearch 发送数据。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>​    网址</p>
<p>​    <a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<h3 id="单机版安装"><a href="#单机版安装" class="headerlink" title="单机版安装"></a>单机版安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建elsearch用户，Elasticsearch不支持root用户运行</span> </span><br><span class="line">useradd elsearch </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压安装包</span> </span><br><span class="line">tar -zxvf elasticsearch-7.10.2-linux-x86_64.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改config文件夹中的 elasticsearch.yml 文件</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 network.host 为0.0.0.0，意为任一网络均可访问</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明:在Elasticsearch中如果，network.host不是localhost或者127.0.0.1的话，就会认为是生产环境，</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 会对elasticsearch启动的要求比较高，我们的测试环境不一定能够满足，一股情况下需要修改2处配置，如下:</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 修改config文件夹中的 jvm.options 文件，</span></span><br><span class="line">-Xms1g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始堆内存</span></span><br><span class="line">-Xmx1g</span><br><span class="line"><span class="meta">#</span><span class="bash">最大堆内存</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改为</span> </span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx128m </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 切换回root用户，修改一个进程在VMAs(虚拟内存区域)创建内存映射最大数量</span> </span><br><span class="line">vim /etc/sysctl.conf </span><br><span class="line">vm.max_map_count=655360 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 使配置生效</span> </span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>启动需要依赖jdk, 解决方法为:</p>
<ol>
<li>开放根目录下的jdk权限，</li>
<li>在elsearch角色下安装jdk并配置在.bash_profile中</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动ES服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接启动</span></span><br><span class="line">./elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台启动</span></span><br><span class="line">./elasticsearch -d</span><br></pre></td></tr></table></figure>
<p><img src="clipboard.png" alt="img"></p>
<p>表示安装并启动成功</p>
<h2 id="head工具的安装及实用"><a href="#head工具的安装及实用" class="headerlink" title="head工具的安装及实用"></a>head工具的安装及实用</h2><p>由于ES官方并没有为ES提供界面管理工具,仅仅是提供了后台的服务。elasticsearch-head是一 个为ES开发的一个页</p>
<p>面客户端工具,其源码托管于GitHub ,地址为: <a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a></p>
<p>head提供了4种安装方式:</p>
<p>● 源码安装,通过npm run start启动(不推荐)</p>
<p>● 通过docker安装 (推荐)</p>
<p>● 通过chrome插件安装 (推荐)</p>
<p>● 通过ES的plugin方式安装 (不推荐)</p>
<h3 id="chrome商店的方式安装-需要翻墙"><a href="#chrome商店的方式安装-需要翻墙" class="headerlink" title="chrome商店的方式安装(需要翻墙)"></a>chrome商店的方式安装(需要翻墙)</h3><p>google应用商店</p>
<p><a href="https://chrome.google.com/webstore/category/extensions?hl=zh">https://chrome.google.com/webstore/category/extensions?hl=zh</a></p>
<p>搜索</p>
<p>elasticsearch head 安装</p>
<p>修改Elasticsearch连接地址即可连接</p>
<p><img src="clipboard.png" alt="img"></p>
<h3 id="通过docker安装（不会）"><a href="#通过docker安装（不会）" class="headerlink" title="通过docker安装（不会）"></a>通过docker安装（不会）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">拉取镜像</span> </span><br><span class="line">docker pull mobz/elasticsearch-head:5 </span><br><span class="line"><span class="meta">#</span><span class="bash">创建容器</span> </span><br><span class="line">docker create --name elasticsearch-head -p 9100:9100 mobz/elasticsearch-head:5 </span><br><span class="line"><span class="meta">#</span><span class="bash">启动容器</span> </span><br><span class="line">docker start elasticsearch-head</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意: 由于前后端分离开发,所以会存在跨域问题,需要在服务端做CORS的配置,如下:</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过chrome插件的方式安装不存在该问题。</span></span><br><span class="line">vim elasticsearch.yml</span><br><span class="line">http.cors.enabled: true http.cors.allow-origin:&quot;*&quot; </span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>技术</category>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK-stack说明</title>
    <url>/2021/03/17/%E6%8A%80%E6%9C%AF/ELK%20stack/0.%20ELK-stack%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><a id="more"></a>

<p>官网</p>
<p><a href="https://www.elastic.co/cn/what-is">https://www.elastic.co</a></p>
<p>官方详细说明</p>
<p><a href="https://www.elastic.co/cn/what-is">https://www.elastic.co/cn/what-is</a></p>
<p>文件存储：</p>
<p>G:\软件\编程\分布式集群\ELK\资料-Elastic Stack 从入门到实践</p>
<h2 id="ELK概念"><a href="#ELK概念" class="headerlink" title="ELK概念"></a>ELK概念</h2><p><strong>需求背景：</strong></p>
<ul>
<li>业务发展越来越庞大，服务器越来越多</li>
<li>各种访问日志、应用日志、错误日志量越来越多，导致运维人员无法很好的去管理日志</li>
<li>开发人员排查问题，需要到服务器上查日志，不方便</li>
<li>运营人员需要一些数据，需要我们运维到服务器上分析日志</li>
</ul>
<p><strong>为什么要用到ELK：</strong></p>
<p>一般我们需要进行日志分析场景：直接在日志文件中 grep、awk 就可以获得自己想要的信息。但在规模较大也就是日志量多而复杂的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。</p>
<p>大型系统通常都是一个分布式部署的架构，不同的服务模块部署在不同的服务器上，问题出现时，大部分情况需要根据问题暴露的关键信息，定位到具体的服务器和服务模块，构建一套集中式日志系统，可以提高定位问题的效率。</p>
<p>一个完整的集中式日志系统，需要包含以下几个主要特点：</p>
<ul>
<li>收集－能够采集多种来源的日志数据</li>
<li>传输－能够稳定的把日志数据传输到中央系统</li>
<li>存储－如何存储日志数据</li>
<li>分析－可以支持 UI 分析</li>
<li>警告－能够提供错误报告，监控机制</li>
</ul>
<p>而ELK则提供了一整套解决方案，并且都是开源软件，之间互相配合使用，完美衔接，高效的满足了很多场合的应用。是目前主流的一种日志系统。</p>
<p><strong>ELK简介：</strong></p>
<p>ELK是三个开源软件的缩写，分别为：Elasticsearch 、 Logstash以及Kibana , 它们都是开源软件。不过现在还新增了一个Beats，它是一个轻量级的日志收集处理工具(Agent)，Beats占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，官方也推荐此工具，目前由于原本的ELK Stack成员中加入了 Beats 工具所以已改名为Elastic Stack。</p>
<p>Elastic Stack包含：</p>
<ul>
<li>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。详细可参考<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">Elasticsearch权威指南</a></li>
<li>Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。</li>
<li>Kibana 也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。</li>
<li>Beats在这里是一个轻量级日志采集器，其实Beats家族有6个成员，早期的ELK架构中使用Logstash收集、解析日志，但是Logstash对内存、cpu、io等资源消耗比较高。相比 Logstash，Beats所占系统的CPU和内存几乎可以忽略不计</li>
</ul>
<p>ELK Stack （5.0版本之后）–&gt; Elastic Stack == （ELK Stack + Beats）。目前Beats包含六种工具：</p>
<ul>
<li>Packetbeat： 网络数据（收集网络流量数据）</li>
<li>Metricbeat： 指标 （收集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）</li>
<li>Filebeat： 日志文件（收集文件数据）</li>
<li>Winlogbeat： windows事件日志（收集 Windows 事件日志数据）</li>
<li>Auditbeat：审计数据 （收集审计日志）</li>
<li>Heartbeat：运行时间监控 （收集系统运行时的数据）</li>
</ul>
<p>关于x-pack工具：</p>
<ul>
<li>x-pack对Elastic Stack提供了安全、警报、监控、报表、图表于一身的扩展包，是收费的，所以本文不涉及x-pack的安装</li>
</ul>
<p>ELK架构图：</p>
<p><img src="clipboard.png" alt="img"></p>
<p>首先beat采集数据，之后可以有两条途径：1. 直接发送elasticsearch储存起来；2. 发送logstash经过logstash处理后发送给elasticsearch</p>
<p>最后在kibana进行数据可视化</p>
<p><img src="928160625881.png" alt="img"></p>
<p><img src="clipboard.png" alt="img"></p>
<h2 id="安装部署结构"><a href="#安装部署结构" class="headerlink" title="安装部署结构"></a>安装部署结构</h2><p>存在多个应用服务器AppServer，每个服务器上都要安装Logstash用来上传本机的日志存储到ElasticSearch(现使用beats进行文件收集)，为保险起见应部署多个ElasticSearch服务器(防止挂了)，Kibana获取ElasticSearch服务器中存储的数据整理成页面供用户查看</p>
<p>用户查看时，查看Logstash服务器什么也不能查到，查看ElasticSearch服务器，查看到的是一大堆日志不够立体，查看Kibana可以看到整理过的数据页面</p>
<h3 id="Elasticsearch-核心"><a href="#Elasticsearch-核心" class="headerlink" title="Elasticsearch (核心)"></a>Elasticsearch (核心)</h3><p>Elasticsearch基于java ,是个开源分布式搜索引擎,它的特点有:分布式,零配置,自动发现,索引自动分片,索引副本机制, restful风格接口,多数据源,自动搜索负载等。</p>
<p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<p>我们建立一个网站或应用程序，并要添加搜索功能，但是想要完成搜索工作的创建是非常困难的。我们希望搜索解决方案要运行速度快，我们希望能有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON通过HTTP来索引数据，我们希望我们的搜索服务器始终可用，我们希望能够从一台开始并扩展到数百台，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。因此我们利用Elasticsearch来解决所有这些问题及可能出现的更多其它问题。</p>
<p>Elasticsearch (yi la si tei ke se chi) 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
<p>Elasticsearch 是一个分布式的开源搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。Elasticsearch 在 Apache Lucene 的基础上开发而成，由 Elasticsearch N.V.（即现在的 Elastic）于 2010 年首次发布。Elasticsearch 以其简单的 REST 风格 API、分布式特性、速度和可扩展性而闻名，是 Elastic Stack 的核心组件；Elastic Stack 是适用于数据采集、充实、存储、分析和可视化的一组开源工具。人们通常将 Elastic Stack 称为 ELK Stack（代指 Elasticsearch、Logstash 和 Kibana），目前 Elastic Stack 包括一系列丰富的轻量型数据采集代理，这些代理统称为 Beats，可用来向 Elasticsearch 发送数据。</p>
<p>与mysql的区别：mysql更倾向于做数据的持久化存储及管理，即CRUD，若单表达到百万级以上的数据，需要进行检索及查询，将会非常慢</p>
<p>mysql支持事务查询，而Elasticsearch不支持，需要实现事务功能时会很麻烦</p>
<h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>Logstash基于java ,是一个开源的用于收集，分析和存储日志的工具。</p>
<h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><p>Kibana基于nodejs ,也是一个开源和免费的工 具, Kibana可以为Logstash和ElasticSearch提供的日志分析友好的Web界面,可以汇总、分析和搜索重要数据日志。</p>
<h3 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h3><p>Beats是elastic公司开源的一款采集系统监控数据的代理agent，是在被监控服务器上以客户端形式运行的数据收集器的统称，可以直接把数据发送给Elasticsearch或者通过Logstash发送给Elasticsearch ，然后进行后续的数据分析活动。</p>
<p>Packetbeat：是一个网络数据包分析器，于监控、收集网络流量信息，Packetbeat嗅探服务器之间的流量，解析应用层协议，并关联到消息的处理，期持ICMP (V4 and Vv6)、DNS、HTTP、Mysql、PostgreSQL、Redis、MongoDB、Memcache等协议；</p>
<p>Filebeat：用于监控、收集服务器日志文件，其已取代logstash、forwarder；</p>
<p>Metricbeat：可定期获取外部系统的监控指标信息，可以监控、收集Apache、HAProxy、 MongoDBMySQL、 Nginx、 PostgreSQL、 Redis、 System、 Zookeeper等服务；</p>
<p>Winlogbeat：用于监控、收集Windows系统的日志信息；</p>
<h2 id="ELK多种架构及优劣"><a href="#ELK多种架构及优劣" class="headerlink" title="ELK多种架构及优劣"></a>ELK多种架构及优劣</h2><p><strong>1</strong>  <strong>架构一 Elasticsearch + Logstash + Kibana</strong></p>
<p>如图1，这是最简单的一种ELK架构方式。优点是搭建简单，易于上手。缺点是Logstash耗资源较大，运行占用CPU和内存高。另外没有消息队列缓存，存在数据丢失隐患。建议供学习者和小规模集群使用。</p>
<p>此架构首先由Logstash分布于各个节点上搜集相关日志、数据，并经过分析、过滤后发送给远端服务器上的Elasticsearch进行存储。Elasticsearch将数据以分片的形式压缩存储并提供多种API供用户查询，操作。用户亦可以更直观的通过配置Kibana Web Portal方便的对日志查询，并根据数据生成报表（详细过程和配置在此省略）。</p>
<p><img src="clipboard-1615972315837.png" alt="img"></p>
<p>图1 ELK架构一</p>
<p><strong>2</strong>  <strong>架构二 引入消息队列</strong></p>
<p>第二种架构（图2）引入了消息队列机制，位于各个节点上的Logstash Agent先将数据/日志传递给Kafka（或者Redis），并将队列中消息或数据间接传递给Logstash，Logstash过滤、分析后将数据传递给Elasticsearch存储。最后由Kibana将日志和数据呈现给用户。因为引入了Kafka（或者Redis）,所以即使远端Logstash server因故障停止运行，数据将会先被存储下来，从而避免数据丢失。</p>
<p><img src="ip_image003.jpeg" alt="img"></p>
<p>图2 ELK架构二</p>
<p>这种架构适合于较大集群的解决方案，但由于Logstash中心节点和Elasticsearch的负荷会比较重，可将他们配置为集群模式，以分担负荷，这种架构的优点在于引入了消息队列机制，均衡了网络传输，从而降低了网络闭塞尤其是丢失数据的可能性，但依然存在Logstash占用系统资源过多的问题。</p>
<p><strong>3</strong>  <strong>架构三 引入Logstash-forwarder</strong></p>
<p>第三种架构（图3）引入了Logstash-forwarder。首先，Logstash-forwarder将日志数据搜集并统一发送给主节点上的Logstash，Logstash分析、过滤日志数据后发送至Elasticsearch存储，并由Kibana最终将数据呈现给用户。</p>
<p><img src="ip_image005.jpeg" alt="img"></p>
<p>图3 ELK架构三</p>
<p>这种架构解决了Logstash在各计算机点上占用系统资源较高的问题。经测试得出，相比Logstash，Logstash-forwarder所占用系统CPU和MEM几乎可以忽略不计。另外，Logstash-forwarder和Logstash间的通信是通过SSL加密传输，起到了安全保障。如果是较大集群，用户亦可以如结构三那样配置logstash集群和Elasticsearch集群，引入High Available机制，提高数据传输和存储安全。更主要的配置多个Elasticsearch服务，有助于搜索和数据存储效率。但在此种架构下发现Logstash-forwarder和Logstash间通信必须由SSL加密传输，这样便有了一定的限制性。</p>
<p><strong>4</strong>  <strong>架构三 将Logstash-forwarder替换为Beats</strong></p>
<p>第四种架构（图4），将Logstash-forwarder替换为Beats。经测试，Beats满负荷状态所耗系统资源和Logstash-forwarder相当，但其扩展性和灵活性有很大提高。Beats platform目前包含有Packagebeat、Topbeat和Filebeat三个产品，均为Apache 2.0 License。同时用户可根据需要进行二次开发。</p>
<p><img src="ip_image006.jpeg" alt="img"></p>
<p>图4 ELK架构四</p>
<p>这种架构原理基于第三种架构，但是更灵活，扩展性更强。同时可配置Logstash 和Elasticsearch 集群用于支持大集群系统的运维日志数据监控和查询。</p>
<p>不管采用上面哪种ELK架构，都包含了其核心组件，即：Logstash、Elasticsearch 和Kibana。当然这三个组件并非不能被替换，只是就性能和功能性而言，这三个组件已经配合的很完美，是密不可分的。各系统运维中究竟该采用哪种架构，可根据现实情况和架构优劣而定。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用问题</title>
    <url>/2021/03/05/%E6%8A%80%E6%9C%AF/git/git%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="提交过大文件到线上仓库，删除该文件无法提交的问题"><a href="#提交过大文件到线上仓库，删除该文件无法提交的问题" class="headerlink" title="提交过大文件到线上仓库，删除该文件无法提交的问题"></a>提交过大文件到线上仓库，删除该文件无法提交的问题</h2><a id="more"></a>

<blockquote>
<p>报错提示</p>
</blockquote>
<p>remote: error: File: 68c625d7c4c72d644859123e74957a00701ca947 128.78 MB, exceeds 100.00 MB.<br>remote: Use command below to see the filename:<br>remote: git rev-list –objects –all | grep 68c625d7c4c72d644859123e74957a00701ca947<br>remote: Please remove the file from history and try again.</p>
<blockquote>
<p>解决方法</p>
</blockquote>
<ol>
<li>使用<code>git clone uri</code>重新拉取一份项目    </li>
<li>使用新项目中的<code>.git</code>替换报错项目中的<code>.git</code>文件夹，存在<code>.gitee</code>文件夹时也一并替换</li>
<li>重新执行提交代码命令即可</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>git概念</title>
    <url>/2021/02/22/%E6%8A%80%E6%9C%AF/git/git%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>什么是版本控制、版本迭代、版本管理器</p>
<a id="more"></a>

<p>​        <code>版本控制</code>( Revision control )是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录,备份以便恢复以前的版本的软件工程技术。<br>​    ●  实现跨区域多人协同开发<br>​    ●  追踪和记载一个或者多个文件的历史记录<br>​    ●  组织和保护你的源代码和文档<br>​    ●  统计工作量<br>​    ●  并行开发、提高开发效率<br>​    ●  跟踪记录整个软件的开发过程<br>​    ●  减轻开发人员的负担,节省时间,同时降低人为错误<br>简单说就是用于管理多人协同开发项目的技术。</p>
<h4 id="手动控制版"><a href="#手动控制版" class="headerlink" title="手动控制版"></a>手动控制版</h4><p><img src="image-20210222092842985.png"></p>
<h3 id="版本控制-1"><a href="#版本控制-1" class="headerlink" title="版本控制"></a>版本控制</h3><p>版本控制包括：检入检出控制、分支和合并、历史记录。</p>
<p>1．检入检出控制<br>        软件开发人员对源文件的修改不能在软件配置管理库中进行，对源文件的修改依赖于基本的文件系统并在各自的工作空间下进行。为了方便软件开发，需要不同的软件开发人员组织各自的工作空间。一般说来，不同的工作空间由不同的目录表示，而对工作空间的访问，由文件系统提供的文件访问权限加以控制。访问控制需要管理各个人员存取或修改一个特定软件配置对象的权限。开发人员能够从库中取出对应项目的配置项进行修改，并检入到软件配置库中，对版本进行“升级”；配置管理人员可以确定多余配置项并删除。同步控制的实质是版本的检入检出控制。检入就是把软件配置项从用户的工作环境存入到软件配置库的过程，检出就是把软件配置项从软件配置库中取出的过程。检人是检出的逆过程。同步控制可用来确保由不同的人并发执行的修改不会产生混乱。</p>
<p>2．分支和合并<br>        版本分支(以一个已有分支的特定版本为起点，但是独立发展的版本序列)的人工方法就是从主版本——称为主干上拷贝一份，并做上标记。在实行了版本控制后，版本的分支也是一份拷贝，这时的拷贝过程和标记动作由版本控制系统完成。版本合并(来自不同分支的两个版本合并为其中一个分支的新版本)有两种途径，一是将版本A的内容附加到版本B中；另一种是合并版本A和版本B的内容，形成新的版本C。</p>
<p>3．历史记录<br>        版本的历史记录有助于对软件配置项进行审核，有助于追踪问题的来源。历史记录包括版本号、版本修改时间、版本修改者、版本修改描述等最基本的内容，还可以有其他一些辅助性内容，比如版本的文件大小和读写属性。</p>
<h3 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h3><p>​    ●  Git<br>​    ●  SVN ( Subversion )<br>​    ●  CVS ( Concurrent Versions System )<br>​    ●  VSS ( Micorosoft Visual SourceSafe )<br>​    ●  TFS ( Team Foundation Server )<br>​    ●  Visual Studio Online</p>
<h3 id="GIT与SVN的区别"><a href="#GIT与SVN的区别" class="headerlink" title="GIT与SVN的区别"></a>GIT与SVN的区别</h3><h4 id="本地版本控制-如RCS"><a href="#本地版本控制-如RCS" class="headerlink" title="本地版本控制(如RCS)"></a>本地版本控制(如RCS)</h4><p>​        记录每次更新，对每个版本做一个快照，如将每次更新做备份然后按日期排版仅适用于个人</p>
<p><img src="image-20210222093134728.png"></p>
<h4 id="集中版本控制-如-SVN"><a href="#集中版本控制-如-SVN" class="headerlink" title="集中版本控制(如 SVN)"></a>集中版本控制(如 SVN)</h4><p>​        所有的版本数据都保存在服务器上,协同开发者从服务器上同步更新或上传自己的修改所有的开发者都与该服务器做交互，若该服务器出现问题，则将无法上传及获取代码，一般解决方法为定期备份代码</p>
<p><img src="image-20210222093238406.png"></p>
<h4 id="分布式版本控制-如git"><a href="#分布式版本控制-如git" class="headerlink" title="分布式版本控制(如git)"></a>分布式版本控制(如git)</h4><p><img src="image-20210222093319633.png"></p>
<h3 id="git基本理论-核心"><a href="#git基本理论-核心" class="headerlink" title="git基本理论(核心)"></a>git基本理论(核心)</h3><h4 id="分支内容存储在HEAD中"><a href="#分支内容存储在HEAD中" class="headerlink" title="分支内容存储在HEAD中"></a>分支内容存储在HEAD中</h4><p><img src="image-20210223180806311.png" alt="image-20210223180806311"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>


<h4 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h4><p>​        git本地有三个工作区域，<code>工作目录(Working Directory)</code>、<code>暂存区(Stage Index)</code>、<code>资源库(Repository或Git Directory)</code>。如果在加上<code>远程的git仓库(Rermote Directory)</code>就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<p><img src="%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p>
<ul>
<li><p>Working Directory：工作区，就是平时存放项目代码的地方</p>
</li>
<li><p>Index / Stage ：暂存区,用于临时存放你的改动，事实上它只是一个文件,保存即将提交到文件列表信息</p>
</li>
<li><p>Repository: 仓库区(或本地仓库),就是安全存放数据的位置 ,这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p>
</li>
<li><p>Remote : 远程仓库（github或gitee码云）,托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p>
</li>
</ul>
<p>其中开发者仅需管理Working Directory和Remote，暂存区和仓库区使用命令操作即可</p>
<p>下图可理解为git管理的项目的示意图:</p>
<p>​    Directory：整个项目</p>
<p>​        WorkSpace：代码文件</p>
<p>​        .git(隐藏文件夹)：其中包括Index暂存区及Head目录</p>
<p><img src="image-20210223181645558.png" alt="image-20210223181645558"></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git安装及配置</title>
    <url>/2021/02/22/%E6%8A%80%E6%9C%AF/git/git%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="淘宝镜像安装地址"><a href="#淘宝镜像安装地址" class="headerlink" title="淘宝镜像安装地址"></a>淘宝镜像安装地址</h3><p><a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></p>
<a id="more"></a>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>需要先清理环境变量，再删除文件</p>
<h3 id="查看git配置"><a href="#查看git配置" class="headerlink" title="查看git配置"></a>查看git配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于git所有的配置</span></span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统配置</span></span><br><span class="line">git config --system --list</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 用户自身的配置   其中用户名和邮箱是必须配置的</span></span><br><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>


<h4 id="所有的配置文件，其实都保存在本地"><a href="#所有的配置文件，其实都保存在本地" class="headerlink" title="所有的配置文件，其实都保存在本地"></a><code>所有的配置文件，其实都保存在本地</code></h4><h4 id="设置用户名和邮箱-用户标识，必要"><a href="#设置用户名和邮箱-用户标识，必要" class="headerlink" title="设置用户名和邮箱(用户标识，必要)"></a>设置用户名和邮箱(用户标识，必要)</h4><h5 id="本地git配置文件位置"><a href="#本地git配置文件位置" class="headerlink" title="本地git配置文件位置"></a>本地git配置文件位置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --system 系统级 旧版位置   </span></span><br><span class="line"><span class="comment">// 新版为位于 Git\mingw64\etc\gitconfig</span></span><br><span class="line">Git\mingw64\etc\gitconfig</span><br><span class="line">    </span><br><span class="line"><span class="comment">// --global 用户配置</span></span><br><span class="line">C:\Users\Administrator\.gitconfig</span><br></pre></td></tr></table></figure>


<h5 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置用户名</span></span><br><span class="line">git config --global user.name <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">// 配置邮箱</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&quot;</span>    </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>技术</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka</title>
    <url>/2021/03/19/%E6%8A%80%E6%9C%AF/kafka/1.%20kafka/</url>
    <content><![CDATA[<h2 id="Kafka概述"><a href="#Kafka概述" class="headerlink" title="Kafka概述"></a>Kafka概述</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>​    Kafka 是一个<code>分布式</code>的基于<code>发布/订阅模式</code>的<code>消息队列</code>（Message Queue），主要应用于大数据实时处理领域。</p>
<p>p6</p>
<h3 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h3><p>​    传统消息队列的应用场景</p>
<p><img src="image-20210322150024538.png" alt="image-20210322150024538"></p>
<p>​    同步需要客户端和服务端要同时在线</p>
<p>​    好处：  （主要为解耦和削峰）</p>
<pre><code>1. 解耦：不需要两端同时在线，允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。
2. 可恢复性：系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
3. 缓冲：有助于控制和优化数据流经过系统的速度解决生产消息和消费消息的处理速度不一致的情况，``主要解决生产大于消费的情况``
4. 灵活性 &amp; 峰值处理能力：``削峰``，缓解服务器压力，在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪 费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。``灵活性``主要体现在可以在峰值时添加服务器以处理突增的访问量。
5. 异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</code></pre>
<h3 id="3-消息队列的两种模式"><a href="#3-消息队列的两种模式" class="headerlink" title="3. 消息队列的两种模式"></a>3. 消息队列的两种模式</h3><p>（1）点对点模式 （一对一，消费者主动拉取数据，消息收到后消息清除）</p>
<p>消息生产者生产消息发送到Queue中 然后消息消费者从 Queue中取出并且消费消息。消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。</p>
<p>Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p>
<p><img src="image-20210322145651680.png" alt="image-20210322145651680"></p>
<p>（2）发布 /订阅模式 （一对多，消费者消费数据之后不会清除） </p>
<p>消息消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic的消息会被所有订阅者消费。</p>
<p>发布/订阅模式又分为两种：</p>
<ol>
<li>消费者端主动拉取的消息队列（消费者若要知道消息队列中有新的消息需要有一个长的轮询，要不断的询问消息队列中是否存在新的消息）</li>
<li>生产者推送的消息队列（由于生产者不清楚消费者的消费速度，因此假设生产者的推送速度为固定的50M/S，若消费者的消费速度为100M/S时就造成了资源浪费，而若消费者的消费速度为10M/S时消费者方就有撑爆崩溃的风险）</li>
</ol>
<p><img src="image-20210322145710577.png" alt="image-20210322145710577"></p>
<h3 id="4-Kafka架构"><a href="#4-Kafka架构" class="headerlink" title="4. Kafka架构"></a>4. Kafka架构</h3><p><img src="image-20210322153158964.png" alt="image-20210322153158964"></p>
<p>1）Producer ：消息生产者，就是向kafka broker 发消息的客户端；<br>2）Consumer ：消息消费者，向kafka broker 取消息的客户端；<br>3）Consumer Group （CG）：消费者组，由多个consumer 组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。<br>4）Broker ：一台kafka 服务器就是一个broker。一个集群由多个broker 组成。一个broker可以容纳多个topic。<br>5）Topic ：可以理解为一个队列，生产者和消费者面向的都是一个topic；<br>6）Partition：为了实现扩展性，一个非常大的topic 可以分布到多个broker（即服务器）上，一个topic 可以分为多个partition，每个partition 是一个有序的队列；<br>7）Replica：副本，为保证集群中的某个节点发生故障时，该节点上的partition 数据不丢失，且kafka仍然能够继续工作 kafka提供了副本机制，一个 topic的每个分区都有若干个副本，一个 leader和若干个 follower。<br>8 leader 每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader。<br>9 follower 每个分区多个副本中的“从”，实时从 leader中同步数据，保持和 leader数据的同步。 leader发生故障时，某个 follower会成为新的 follower。</p>
<h4 id="生产者与集群存储"><a href="#生产者与集群存储" class="headerlink" title="生产者与集群存储"></a>生产者与集群存储</h4><h5 id="Topic-主题"><a href="#Topic-主题" class="headerlink" title="Topic    主题"></a>Topic    主题</h5><p>消息不是直接存在Broker中，而是会有不同的Topic(主题)，将消息做一个分类</p>
<p><img src="clipboard-1616398616151.png" alt="img"></p>
<p><img src="clipboard-1616398626047.png" alt="img"></p>
<p>即：A要与B通信、C要与D通信，若B和D直接从Kafka中拿消息，那么拿到的就是A和C全部的消息，就乱套了</p>
<p>由此可以建一个AB主题和一个CD主题，A发送消息时发送到AB主题中，B又从AB主题中获取数据，CD同理</p>
<p>主题的作用就是将数据进行一个分类</p>
<h5 id="Partition-分区"><a href="#Partition-分区" class="headerlink" title="Partition    分区"></a>Partition    分区</h5><p>多个服务器上相同的主题建立多个分区，当消费者请求来的时候会进行轮循，增加了Kafka集群的负载能力</p>
<h5 id="Leader-Follower-主-备份-备胎"><a href="#Leader-Follower-主-备份-备胎" class="headerlink" title="Leader/Follower    主/备份(备胎)"></a>Leader/Follower    主/备份(备胎)</h5><p><img src="clipboard-1616398690814.png" alt="img"></p>
<p>作为一个高可靠高可用的备份的消息队列，若消息只存一份若存储数据的机器挂了，那么数据将不能访问</p>
<p>使用Leader/Follower后，当一台服务器上的Leader挂掉以后，会将另外一台服务器上的Follower提升为Leader，再次访问时可以访问新的Leader保证了数据</p>
<p>无论是生产者生产还是消费者消费都是找Leader，也只能联系到Leader</p>
<h4 id="生产者与集群存储总结"><a href="#生产者与集群存储总结" class="headerlink" title="生产者与集群存储总结"></a>生产者与集群存储总结</h4><p>集群存储核心：主题</p>
<p>主题： </p>
<ol>
<li><p>分区 </p>
</li>
<li><p>每个分区有副本(副本分Leader/Follower)</p>
</li>
<li><p>无论是生产者生产还是消费者消费都是找Leader，也只能联系到Leader</p>
</li>
</ol>
<h4 id="生产者、集群存储与消费者"><a href="#生产者、集群存储与消费者" class="headerlink" title="生产者、集群存储与消费者"></a>生产者、集群存储与消费者</h4><h5 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h5><p><img src="clipboard-1616398731934.png" alt="img"></p>
<ol>
<li>一个分区partition只能被一个消费者组里边的某一个消费者消费</li>
</ol>
<p><img src="image-20210322160659653.png" alt="image-20210322160659653"></p>
<ol start="2">
<li><p>消费者组可以当成一个大的消费团体(是为了解决并发)</p>
</li>
<li><p>消费者组可以<code>提高消费能力</code>，若有100条数据，如果消费者组中只有一个消费者需要消费100条数据，若消费者组中有两个消费者，则每个消费者只需消费50条数据</p>
</li>
<li><p>而当消费者组中消费者个数大于主题分区数，由于一个分区只能被一个消费者组里边的某一个消费者消费，因此多出的消费组中的消费者就只能闲置，造成资源浪费，因此并发最好的情况为：<code>消费者组中的消费者数量 等于 主题的分区数</code></p>
</li>
</ol>
<h3 id="5-Zookeeper"><a href="#5-Zookeeper" class="headerlink" title="5. Zookeeper"></a>5. Zookeeper</h3><p>Kafka整个集群要正常工作，需要依赖于ZK，zk会帮助集群存储信息</p>
<p>ZK会帮助Kafka管理整个集群</p>
<p>消费者也会存某些消息，如：消费者挂了，运行正常后可以接着消费而不是从头开始消费</p>
<p>因此消费者会将消费到的位置信息保存在ZK中</p>
<p>0.9版本前会将信息存储在ZK中，0.9版本之后会将信息存在Kafka本地中</p>
<p>改的原因：消费者本身跟Kafka集群进行通信，消费者在与Kafka维护连接的同时还要维护与ZK的连接</p>
<p>消费者是以拉取的模式获取连接的，拉取得速度是非常快的，而将信息存到zk中时，拉取得同时还得和zk进行沟通，跟zk打交道就太过频繁</p>
<p>Kafka存储数据是存在磁盘中的，因为其默认保留七天(配置文件中配置保存168小时)，内存办不到</p>
<p>​    </p>
]]></content>
      <categories>
        <category>技术</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2021/03/22/%E6%8A%80%E6%9C%AF/nginx/1.%20nginx/</url>
    <content><![CDATA[<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><p>p4</p>
<p>项目部署到线上时，用户使用少，并发量小，仅使用tomcat返回内容给用户，项目只需一个jar包就够了</p>
<p>当访问人数越来越多，并发量慢慢增大，一台服务器已经不能满足需求</p>
<p>于是可以增加服务器，讲项目启动在不同的服务器上，用户访问代理服务器，代理服务器帮助我们转发和处理请求</p>
<p>因此代理服务器需要具有以下特点：</p>
<ol>
<li>负载均衡（给性能强的服务器增加权重，使请求更多的访问到该服务器上）</li>
<li>反向代理</li>
</ol>
<p><img src="image-20210322174144218.png" alt="image-20210322174144218"></p>
<p>我们希望这个代理服务器可以帮助我们接收用户的请求。然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的。用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验!</p>
<h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><p>Nginx (engine x)是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是 由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点开发的,第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日, nginx 1.0.4发布。</p>
<p>其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有:百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。<br>Nginx是-个安装非常的简单、配置文件非常简洁(还能够支持perl语法)、Bug非常少的服务。Nginx启动特别容易，并且几乎可以做到7*24不问断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。<br>Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达50,000个并发连接数的响应。</p>
<h1 id="Nginx作用"><a href="#Nginx作用" class="headerlink" title="Nginx作用"></a>Nginx作用</h1><blockquote>
<p>Http代理，反向代理</p>
</blockquote>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p><code>代理客户端</code></p>
<p>如：VPN，国内存在防火墙，客户端无法访问国外网站，而客户端使用VPM先可以访问代理服务器，代理服务器访问外国网站，此类代理即为正向代理</p>
<p><img src="image-20210322175141813.png" alt="image-20210322175141813"></p>
<h3 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h3><p><code>代理服务器端</code></p>
<p>如：访问百度网址，百度存在多台服务器，用户仅需通过<a href="http://www.baidu.com访问代理服务器即可,无法感知自身访问的到底是哪台服务器/">www.baidu.com访问代理服务器即可，无法感知自身访问的到底是哪台服务器</a></p>
<p><img src="image-20210322175500931.png" alt="image-20210322175500931"></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p><img src="image-20210322175956175.png" alt="image-20210322175956175"></p>
<h3 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h3><p>保证服务器性能最大化</p>
<p><img src="image-20210322180033474.png" alt="image-20210322180033474"></p>
<h3 id="session共享"><a href="#session共享" class="headerlink" title="session共享"></a>session共享</h3><p>iphash对客户端请求的ip进行hash操作。然后根据hash结果将同一个客户端ip的请求分发给同- -台服务器进行处理，可以解决session不共享的问题。</p>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的(如: css、 html. jpog. js等等文件)，这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来， 动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。</p>
<p><img src="image-20210322190527587.png" alt="image-20210322190527587"></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2021/03/02/%E7%B3%BB%E7%BB%9F/Linux/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><a id="more"></a>

<blockquote>
<h3 id="系统信息查看"><a href="#系统信息查看" class="headerlink" title="系统信息查看"></a>系统信息查看</h3></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 系统内核</span><br><span class="line">uname -r</span><br><span class="line">-- <span class="number">2.6</span><span class="number">.32</span>-<span class="number">431.</span>el6.x86_64</span><br><span class="line">    </span><br><span class="line"># 系统版本</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h3></blockquote>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><code>make</code></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>make PREFIX=/usr/local/redis install</code></p>
<blockquote>
<p>这里多了一个关键字 <strong>PREFIX=</strong> 这个关键字的作用是编译的时候用于指定程序存放的路径。比如我们现在就是指定了redis必须存放在/usr/local/redis目录。假设不添加该关键字Linux会将可执行文件存放在/usr/local/bin目录，库文件会存放在/usr/local/lib目录。配置文件会存放在/usr/local/etc目录。其他的资源文件会存放在usr/local/share目录。这里指定号目录也方便后续的卸载，后续直接rm -rf /usr/local/redis 即可删除redis。</p>
</blockquote>
]]></content>
      <tags>
        <tag>系统-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka安装</title>
    <url>/2021/03/22/%E6%8A%80%E6%9C%AF/kafka/2.%20kafka%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>虚拟机安装Linux</title>
    <url>/2021/03/03/%E7%B3%BB%E7%BB%9F/Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Linux/</url>
    <content><![CDATA[<h2 id="安装报错"><a href="#安装报错" class="headerlink" title="安装报错"></a>安装报错</h2><a id="more"></a>

<h3 id="Section-packages-does-not-end-with-end"><a href="#Section-packages-does-not-end-with-end" class="headerlink" title="Section packages does not end with %end"></a>Section packages does not end with %end</h3><p>方法1 ： VM极简安装模式会自动生成一个autoinst.iso，自动索引镜像，将这个删掉就好了：</p>
<p>先将这个centos虚拟机系统关机，然后从我的机算机清单中找到这个菜单，左键点击选中这个菜单，然后右键，会看到设置选项，进去就能看到一个CD/DVD(IDE) autoinst.iso，删掉，重新开启centos虚拟机系统，就能正常安装了</p>
<p>方法2 ： 原因为虚拟机找不到镜像文件，设置方法：</p>
<p><img src="image-20210303144902140.png" alt="image-20210303144902140"></p>
<p><img src="image-20210303144932408.png" alt="image-20210303144932408"></p>
<p>找到自身镜像文件位置即可</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>阿里镜像地址</p>
</blockquote>
<p><a href="https://mirrors.aliyun.com/centos/8/isos/x86_64/">https://mirrors.aliyun.com/centos/8/isos/x86_64/</a></p>
<p>选择</p>
<p><img src="image-20210303145132219.png" alt="image-20210303145132219"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>generator函数</title>
    <url>/2021/02/24/java/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0/generator%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h2><ul>
<li>yield是ES6的新关键字，使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字。</li>
<li>yield关键字实际返回一个IteratorResult（迭代器）对象，它有两个属性，value和done，分别代表返回值和是否完成。</li>
<li>yield无法单独工作，需要配合generator(生成器)的其他函数，如next，懒汉式操作，展现强大的主动控制特性。</li>
</ul>
<p>​    <a id="more"></a></p>
<h2 id="generator使用"><a href="#generator使用" class="headerlink" title="generator使用"></a>generator使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; list.length; index++) </span><br><span class="line">        <span class="keyword">yield</span> list[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取generator对象</span></span><br><span class="line"><span class="keyword">let</span> gen = generator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行next()方法获取迭代结果和是否完成</span></span><br><span class="line"><span class="comment">// 结果： &#123;value: 1, done: false&#125;</span></span><br><span class="line">gen.next();</span><br></pre></td></tr></table></figure>


<h3 id="懒汉式加载"><a href="#懒汉式加载" class="headerlink" title="懒汉式加载"></a>懒汉式加载</h3><blockquote>
<p> 此处可以看出循环中的打印是在Generator对象调用next方法后产生的，由此可知打印代码为next方法调用后执行</p>
</blockquote>
<p><img src="image-20210224111746190.png" alt="image-20210224111746190"></p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><blockquote>
<p>只要调用next方法，就会执行一次代码不论是在什么场景下(打印，判断)</p>
</blockquote>
<p><img src="image-20210224112336096.png" alt="image-20210224112336096"></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>yield并不能直接生产值，而是产生一个等待输出的函数</p>
</li>
<li><p>除IE外，其他所有浏览器均可兼容（包括win10 的Edge）</p>
</li>
<li><p>某个函数包含了yield，意味着这个函数已经是一个Generator</p>
</li>
<li><p>如果yield在其他表达式中，需要用()单独括起来</p>
</li>
<li><p>yield表达式本身没有返回值，或者说总是返回undefined(由next返回) <code>注</code></p>
</li>
</ul>
<ul>
<li>next()可无限调用，但既定循环完成之后总是返回undeinded</li>
</ul>
<blockquote>
<p>注：当yield在赋值表达式的右边，比如 var result = yield 4，yield语句本身没有返回值，或者说返回值是undefined，但是当我们调用next(param)传参的时候，param不但作为next返回对象的value值，它还作为上一条yield 的返回值，所以result 才会被成功赋值。</p>
</blockquote>
<h2 id="next-函数及参数"><a href="#next-函数及参数" class="headerlink" title="next()函数及参数"></a>next()函数及参数</h2><ol>
<li> 在js中，虽然借鉴了python的函数，但是也进行了自己的改造，由于没有send()函数，所以无法直接传递yield的值。</li>
<li> next()可以带一个参数，该参数会被认为是上一个yield整体的返回值，稍后将在代码中展示。</li>
<li> 在某种程度上，next()可以直接当做send()使用</li>
</ol>
<p><strong>它的意义在于，可以在不同阶段从外部直接向内部注入不同的值来调整函数的行为(这一点是其他循环很难做到的，或要付出较大的代价才可以做到)</strong></p>
<h2 id="目前项目中的可用性"><a href="#目前项目中的可用性" class="headerlink" title="目前项目中的可用性"></a>目前项目中的可用性</h2><p>在前端项目中，用的机会很少，完全可以忽略他的存在，但是在后台项目中，就显得比较重要了，因为其优越的可控性，可是极大的提升线程的效率。</p>
<p>如果需要实例的话，可参考github上的一些python后端项目，调用方式稍有不同，由于js参考的python语言，他们又同为动态语言，所以原理都是相同的，用处也一样。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>前端-函数</tag>
      </tags>
  </entry>
  <entry>
    <title>js高阶函数</title>
    <url>/2021/03/08/java/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0/js%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><a id="more"></a>

<p><strong>高阶函数</strong>就是那种输入参数里面有一个或者多个函数，输出也是函数的函数，这个在js里面主要是利用闭包实现的，最简单的就是经常看到的在一个函数内部输出另一个函数</p>
<h2 id="常见的高阶函数"><a href="#常见的高阶函数" class="headerlink" title="常见的高阶函数"></a>常见的高阶函数</h2><h3 id="filter-map-reduce"><a href="#filter-map-reduce" class="headerlink" title="filter/ map/ reduce"></a>filter/ map/ reduce</h3><p>// filter</p>
<p>// 筛选数组中大于2的</p>
<p>let array = [1,2,3]</p>
<p>array.filter(item =&gt; {</p>
<p>return item &gt; 2;</p>
<p>})</p>
<p>得到[3]</p>
<p>// reduce</p>
<p>// 对数组中的内容进行运算，并将(运算结果, 下一项)传到下一轮</p>
<p>let array = [1, 2, 3]</p>
<p>array.reduce((a,b) =&gt; {return a + b})</p>
<p>得到 6</p>
<p>let array = [1, 2, 3]</p>
<p>array.reduce((a,b) =&gt; {return a + b}, 0)</p>
<p>最后面的 0 为初始化的值，即第一轮a为0</p>
<p>// map</p>
<p>// 对数组中的每个元素进行统一处理</p>
<p>let array = [1,2,3]</p>
<p>array.map(item =&gt; {</p>
<p>return item * 2;</p>
<p>})</p>
<p>得到 [2, 4, 6]</p>
<p>// 综合  函数式编程</p>
<p>array.filter(item =&gt; {</p>
<p>return item &gt; 2;</p>
<p>}).map(item =&gt; {</p>
<p>return item * 2;</p>
<p>}).reduce((a,b) =&gt; {</p>
<p>return a + b</p>
<p>}, 0);</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3>]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>observer观察者</title>
    <url>/2021/02/24/java/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0/observer%E8%A7%82%E5%AF%9F%E8%80%85/</url>
    <content><![CDATA[<h2 id="创建观察者监测dom元素的改变"><a href="#创建观察者监测dom元素的改变" class="headerlink" title="创建观察者监测dom元素的改变"></a>创建观察者监测dom元素的改变</h2><p>可监测属性、子节点及节点内容的改变</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建观察者对象</span></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">    mutations.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">mutation</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(mutation)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置观察者选项</span></span><br><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">    attributes: <span class="literal">true</span>,   <span class="comment">//检测属性变动</span></span><br><span class="line">    childList: <span class="literal">true</span>,    <span class="comment">//检测子节点变动</span></span><br><span class="line">    characterData: <span class="literal">true</span> <span class="comment">//节点内容或节点文本的变动。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入目标节点和观察选项</span></span><br><span class="line">observer.observe(<span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;addFeeConfigStartTime_div&quot;</span>)[<span class="number">0</span>], config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止监测</span></span><br><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>前端-函数</tag>
      </tags>
  </entry>
  <entry>
    <title>其他函数</title>
    <url>/2021/03/08/java/%E5%89%8D%E7%AB%AF/%E5%87%BD%E6%95%B0/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><a id="more"></a>

<p>let arra = [{name:123},{name:456},{name:789}];</p>
<p>let obj = arra.find(item =&gt; {return item[“name”] == 456})</p>
<p>.</p>
<p>得到{name: 456}</p>
<p>find 返回首个符合标准的</p>
<p>filter返回集合</p>
<p><img src="clipboard.png" alt="img"></p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>splice  插入和删除</p>
<p>list.splice(开始的下标, 删除几个, 插入的元素)</p>
<h3 id="replace-js替换所有匹配项"><a href="#replace-js替换所有匹配项" class="headerlink" title="replace  js替换所有匹配项"></a>replace  js替换所有匹配项</h3><p>let list = [1,2,3,4]</p>
<p>let json = JSON.stringify(list)</p>
<p>let regex = new RegExp(“,”, “g”)</p>
<p>json.replace(regex,”;”)</p>
<p>或</p>
<p>let list = [1,2,3,4]</p>
<p>let json = JSON.stringify(list)</p>
<p>json.replace(/,/g, “;”)</p>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>前端判断</title>
    <url>/2021/02/23/java/%E5%89%8D%E7%AB%AF/%E5%88%A4%E6%96%AD/%E5%89%8D%E7%AB%AF%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="对象-Map集合"><a href="#对象-Map集合" class="headerlink" title="对象(Map集合)"></a>对象(Map集合)</h2><h3 id="判断是否为对象的几种方法"><a href="#判断是否为对象的几种方法" class="headerlink" title="判断是否为对象的几种方法"></a>判断是否为对象的几种方法</h3><a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;) === <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断指定参数是否是一个纯粹的对象（所谓&quot;纯粹的对象&quot;，就是该对象是通过&quot;&#123;&#125;&quot;或&quot;new Object&quot;创建的。）</span></span><br><span class="line">$.isPlainObject(obj);</span><br></pre></td></tr></table></figure>


<h3 id="判断对象中是否包含某个key"><a href="#判断对象中是否包含某个key" class="headerlink" title="判断对象中是否包含某个key"></a>判断对象中是否包含某个key</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hasOwnProperty</span></span><br><span class="line">map.hasOwnProperty(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(map, <span class="string">&quot;aa&quot;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="数组判断"><a href="#数组判断" class="headerlink" title="数组判断"></a>数组判断</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象是否为数组</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(list);</span><br></pre></td></tr></table></figure>


<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constructor</span></span><br><span class="line">&#123;&#125;.constructor === <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof  根据typeof判断对象也不太准确</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; === <span class="built_in">Object</span></span><br><span class="line"><span class="comment">// 表达式	                      返回值</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>	       <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>	               <span class="string">&#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>	               <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>	               <span class="string">&#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;abc&quot;</span>	           <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;	   <span class="string">&#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;	               <span class="string">&#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> []	               <span class="string">&#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>


























]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>判断</category>
      </categories>
      <tags>
        <tag>前端-判断</tag>
      </tags>
  </entry>
  <entry>
    <title>图片</title>
    <url>/2021/03/08/java/%E5%89%8D%E7%AB%AF/%E6%96%87%E4%BB%B6/%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h2><a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载成功</span></span><br><span class="line">img.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;图片加载成功&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载失败</span></span><br><span class="line">img.onerror = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;图片加载失败&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="图片转base64"><a href="#图片转base64" class="headerlink" title="图片转base64"></a>图片转base64</h2><p>将图片链接直接转成base64位编码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase64Image</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">    canvas.width = img.width;</span><br><span class="line">    canvas.height = img.height;</span><br><span class="line">    <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, img.width, img.height);</span><br><span class="line">    <span class="keyword">let</span> ext = img.src.substring(img.src.lastIndexOf(<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">let</span> dataURL = canvas.toDataURL(<span class="string">&quot;image/&quot;</span>+ext);</span><br><span class="line">    <span class="keyword">return</span> dataURL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> imgLink = <span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fa3.att.hudong.com%2F35%2F34%2F19300001295750130986345801104.jpg&amp;refer=http%3A%2F%2Fa3.att.hudong.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1618557160&amp;t=55fd99168b1618ede7a554b27cdb3fd3&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> tempImage = <span class="keyword">new</span> Image();</span><br><span class="line">tempImage.src = imgLink;</span><br><span class="line">tempImage.crossOrigin = <span class="string">&quot;*&quot;</span>;</span><br><span class="line">tempImage.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> base64 = getBase64Image(tempImage);</span><br><span class="line">    <span class="built_in">console</span>.log(base64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>image.crossOrigin = &quot;*&quot;</code>是防止跨域请求时报错<code>Failed to execute &#39;toDataURL&#39; on &#39;HTMLCanvasElement&#39;</code></p>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>文件</category>
      </categories>
      <tags>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>js添加水印</title>
    <url>/2021/03/19/java/%E5%89%8D%E7%AB%AF/%E5%AE%9E%E7%8E%B0/js%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watermark</span> (<span class="params">settings</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//默认设置</span></span><br><span class="line">    <span class="keyword">var</span> defaultSettings=&#123;</span><br><span class="line">        watermark_txt:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">        watermark_x:<span class="number">20</span>,<span class="comment">//水印起始位置x轴坐标</span></span><br><span class="line">        watermark_y:<span class="number">20</span>,<span class="comment">//水印起始位置Y轴坐标</span></span><br><span class="line">        watermark_rows:<span class="number">100</span>,<span class="comment">//水印行数</span></span><br><span class="line">        watermark_cols:<span class="number">20</span>,<span class="comment">//水印列数</span></span><br><span class="line">        watermark_x_space:<span class="number">10</span>,<span class="comment">//水印x轴间隔</span></span><br><span class="line">        watermark_y_space:<span class="number">10</span>,<span class="comment">//水印y轴间隔</span></span><br><span class="line">        watermark_color:<span class="string">&#x27;#aaa&#x27;</span>,<span class="comment">//水印字体颜色</span></span><br><span class="line">        watermark_alpha:<span class="number">0.3</span>,<span class="comment">//水印透明度</span></span><br><span class="line">        watermark_fontsize:<span class="string">&#x27;15px&#x27;</span>,<span class="comment">//水印字体大小</span></span><br><span class="line">        watermark_font:<span class="string">&#x27;微软雅黑&#x27;</span>,<span class="comment">//水印字体</span></span><br><span class="line">        watermark_width:<span class="number">150</span>,<span class="comment">//水印宽度</span></span><br><span class="line">        watermark_height:<span class="number">80</span>,<span class="comment">//水印长度</span></span><br><span class="line">        watermark_angle:<span class="number">15</span><span class="comment">//水印倾斜度数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//采用配置项替换默认值，作用类似jquery.extend</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length===<span class="number">1</span>&amp;&amp;<span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>] ===<span class="string">&quot;object&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> src=<span class="built_in">arguments</span>[<span class="number">0</span>]||&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(key <span class="keyword">in</span> src)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(src[key]&amp;&amp;defaultSettings[key]&amp;&amp;src[key]===defaultSettings[key])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(src[key])</span><br><span class="line">                defaultSettings[key]=src[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> oTemp = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取页面最大宽度</span></span><br><span class="line">    <span class="keyword">let</span> page_width = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollWidth,<span class="built_in">document</span>.body.clientWidth);</span><br><span class="line">    <span class="keyword">let</span> cutWidth = page_width*<span class="number">0.0150</span>;</span><br><span class="line">     page_width=page_width-cutWidth;</span><br><span class="line">    <span class="comment">//获取页面最大高度</span></span><br><span class="line">    <span class="keyword">let</span> page_height = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.body.scrollHeight-<span class="number">80</span>,<span class="built_in">document</span>.body.clientHeight-<span class="number">40</span>);</span><br><span class="line">    <span class="comment">// var page_height = document.body.scrollHeight+document.body.scrollTop;</span></span><br><span class="line">    <span class="comment">//如果将水印列数设置为0，或水印列数设置过大，超过页面最大宽度，则重新计算水印列数和水印x轴间隔</span></span><br><span class="line">    <span class="keyword">if</span> (defaultSettings.watermark_cols == <span class="number">0</span> || (<span class="built_in">parseInt</span>(defaultSettings.watermark_x + defaultSettings.watermark_width *defaultSettings.watermark_cols + defaultSettings.watermark_x_space * (defaultSettings.watermark_cols - <span class="number">1</span>)) &gt; page_width)) &#123;</span><br><span class="line">        defaultSettings.watermark_cols = <span class="built_in">parseInt</span>((page_width-defaultSettings.watermark_x+defaultSettings.watermark_x_space) / (defaultSettings.watermark_width + defaultSettings.watermark_x_space));</span><br><span class="line">        defaultSettings.watermark_x_space = <span class="built_in">parseInt</span>((page_width - defaultSettings.watermark_x - defaultSettings.watermark_width * defaultSettings.watermark_cols) / (defaultSettings.watermark_cols - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果将水印行数设置为0，或水印行数设置过大，超过页面最大长度，则重新计算水印行数和水印y轴间隔</span></span><br><span class="line">    <span class="keyword">if</span> (defaultSettings.watermark_rows == <span class="number">0</span> || (<span class="built_in">parseInt</span>(defaultSettings.watermark_y + defaultSettings.watermark_height * defaultSettings.watermark_rows + defaultSettings.watermark_y_space * (defaultSettings.watermark_rows - <span class="number">1</span>)) &gt; page_height)) &#123;</span><br><span class="line">        defaultSettings.watermark_rows = <span class="built_in">parseInt</span>((defaultSettings.watermark_y_space + page_height - defaultSettings.watermark_y) / (defaultSettings.watermark_height + defaultSettings.watermark_y_space));</span><br><span class="line">        defaultSettings.watermark_y_space = <span class="built_in">parseInt</span>(((page_height - defaultSettings.watermark_y) - defaultSettings.watermark_height * defaultSettings.watermark_rows) / (defaultSettings.watermark_rows - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    <span class="keyword">let</span> y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; defaultSettings.watermark_rows; i++) &#123;</span><br><span class="line">        y = defaultSettings.watermark_y + (defaultSettings.watermark_y_space + defaultSettings.watermark_height) * i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; defaultSettings.watermark_cols; j++) &#123;</span><br><span class="line">            x = defaultSettings.watermark_x + (defaultSettings.watermark_width + defaultSettings.watermark_x_space) * j ;</span><br><span class="line">               <span class="keyword">var</span> mask_div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">               mask_div.id = <span class="string">&#x27;mask_div&#x27;</span> + i + j;</span><br><span class="line">               mask_div.className = <span class="string">&#x27;mask_div&#x27;</span>;</span><br><span class="line">               mask_div.appendChild(<span class="built_in">document</span>.createTextNode(defaultSettings.watermark_txt));</span><br><span class="line">               <span class="comment">//设置水印div倾斜显示</span></span><br><span class="line">               mask_div.style.webkitTransform = <span class="string">&quot;rotate(-&quot;</span> + defaultSettings.watermark_angle + <span class="string">&quot;deg)&quot;</span>;</span><br><span class="line">               mask_div.style.MozTransform = <span class="string">&quot;rotate(-&quot;</span> + defaultSettings.watermark_angle + <span class="string">&quot;deg)&quot;</span>;</span><br><span class="line">               mask_div.style.msTransform = <span class="string">&quot;rotate(-&quot;</span> + defaultSettings.watermark_angle + <span class="string">&quot;deg)&quot;</span>;</span><br><span class="line">               mask_div.style.OTransform = <span class="string">&quot;rotate(-&quot;</span> + defaultSettings.watermark_angle + <span class="string">&quot;deg)&quot;</span>;</span><br><span class="line">               mask_div.style.transform = <span class="string">&quot;rotate(-&quot;</span> + defaultSettings.watermark_angle + <span class="string">&quot;deg)&quot;</span>;</span><br><span class="line">               mask_div.style.visibility = <span class="string">&quot;&quot;</span>;</span><br><span class="line">               mask_div.style.position = <span class="string">&quot;fixed&quot;</span>;</span><br><span class="line">               mask_div.style.left = x + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">               mask_div.style.top = y + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">               mask_div.style.overflow = <span class="string">&quot;hidden&quot;</span>;</span><br><span class="line">               mask_div.style.zIndex = <span class="string">&quot;9999&quot;</span>;</span><br><span class="line">               mask_div.style.pointerEvents=<span class="string">&#x27;none&#x27;</span>;<span class="comment">//pointer-events:none  让水印不遮挡页面的点击事件</span></span><br><span class="line">               <span class="comment">//mask_div.style.border=&quot;solid #eee 1px&quot;;</span></span><br><span class="line">               mask_div.style.opacity = defaultSettings.watermark_alpha;</span><br><span class="line">               mask_div.style.fontSize = defaultSettings.watermark_fontsize;</span><br><span class="line">               mask_div.style.fontFamily = defaultSettings.watermark_font;</span><br><span class="line">               mask_div.style.color = defaultSettings.watermark_color;</span><br><span class="line">               mask_div.style.textAlign = <span class="string">&quot;center&quot;</span>;</span><br><span class="line">               mask_div.style.width = defaultSettings.watermark_width + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">               mask_div.style.height = defaultSettings.watermark_height + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">               mask_div.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">               <span class="comment">//交叉网格显示</span></span><br><span class="line">               <span class="keyword">if</span>((i%<span class="number">2</span>==<span class="number">0</span>)&amp;&amp;(j%<span class="number">2</span>==<span class="number">0</span>))&#123;</span><br><span class="line">                  oTemp.appendChild(mask_div);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>((i%<span class="number">2</span>==<span class="number">1</span>)&amp;&amp;(j%<span class="number">2</span>==<span class="number">1</span>))&#123;</span><br><span class="line">                  oTemp.appendChild(mask_div);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(oTemp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>实现</category>
      </categories>
      <tags>
        <tag>水印</tag>
      </tags>
  </entry>
  <entry>
    <title>前端生成Excel并下载</title>
    <url>/2021/02/23/java/%E5%89%8D%E7%AB%AF/%E5%AE%9E%E7%8E%B0/%E5%89%8D%E7%AB%AF%E7%94%9F%E6%88%90Excel%E5%B9%B6%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="通过将json遍历进行字符串拼接，将字符串输出到csv文件（不推荐）"><a href="#通过将json遍历进行字符串拼接，将字符串输出到csv文件（不推荐）" class="headerlink" title="通过将json遍历进行字符串拼接，将字符串输出到csv文件（不推荐）"></a>通过将json遍历进行字符串拼接，将字符串输出到csv文件（不推荐）</h3><a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端生成Excel表格并下载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fileName 文件名称(如：费用表)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>titleMap 表头对象 &#123;&quot;userId&quot;:&quot;员工编号&quot;, &quot;userName&quot;:&quot;员工姓名&quot;&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>dataList 数据list [&#123;&quot;userId&quot;:&quot;123&quot;, &quot;userName&quot;:&quot;张三&quot;&#125;, &#123;&quot;userId&quot;:&quot;456&quot;, &quot;userName&quot;:&quot;李四&quot;&#125;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vc.createExcelByFront = <span class="function"><span class="keyword">function</span> (<span class="params">fileName, titleMap, dataList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(dataList) || <span class="built_in">Object</span>.prototype.toString.call(titleMap) !== <span class="string">&#x27;[object Object]&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&quot;数据list格式错误&quot;</span>);</span><br><span class="line">    <span class="comment">// 列标题，逗号隔开，每一个逗号就是隔开一个单元格</span></span><br><span class="line">    <span class="keyword">let</span> title = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> titleMap) &#123;</span><br><span class="line">        title += titleMap[key] + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    title += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 增加\t为了不让表格显示科学计数法或者其他格式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; dataList.length ; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> titleMap) &#123;</span><br><span class="line">            title += <span class="string">`<span class="subst">$&#123;dataList[i][key] + <span class="string">&#x27;\t&#x27;</span>&#125;</span>,`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        title+=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// encodeURIComponent解决中文乱码</span></span><br><span class="line">    <span class="keyword">const</span> uri = <span class="string">&#x27;data:text/csv;charset=utf-8,\ufeff&#x27;</span> + <span class="built_in">encodeURIComponent</span>(title);</span><br><span class="line">    <span class="comment">// 通过创建a标签实现</span></span><br><span class="line">    <span class="keyword">const</span> link = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    link.href = uri;</span><br><span class="line">    <span class="comment">// 对下载的文件命名</span></span><br><span class="line">    link.download =  fileName ? (fileName + <span class="string">&quot;.xls&quot;</span>) : <span class="string">&quot;下载.xls&quot;</span>;</span><br><span class="line">    link.click();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="将table标签，包括tr、td等对json数据进行拼接，将table输出到表格上实现-不推荐"><a href="#将table标签，包括tr、td等对json数据进行拼接，将table输出到表格上实现-不推荐" class="headerlink" title="将table标签，包括tr、td等对json数据进行拼接，将table输出到表格上实现(不推荐)"></a>将table标签，包括tr、td等对json数据进行拼接，将table输出到表格上实现(不推荐)</h3><p>这种方法的弊端在于输出的是伪excel，虽说生成xls为后缀的文件，但文件形式上还是html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;p style=<span class="string">&quot;font-size: 20px;color: red;&quot;</span>&gt;使用table标签方式将json导出xls文件&lt;/p&gt;</span><br><span class="line">    &lt;button onclick=<span class="string">&#x27;tableToExcel()&#x27;</span>&gt;导出&lt;/button&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;  </span><br><span class="line">    <span class="keyword">const</span> tableToExcel = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 要导出的json数据</span></span><br><span class="line">        <span class="keyword">const</span> jsonData = [</span><br><span class="line">            &#123;</span><br><span class="line">                name:<span class="string">&#x27;路人甲&#x27;</span>,</span><br><span class="line">                phone:<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">                email:<span class="string">&#x27;123@123456.com&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name:<span class="string">&#x27;炮灰乙&#x27;</span>,</span><br><span class="line">                phone:<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">                email:<span class="string">&#x27;123@123456.com&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name:<span class="string">&#x27;土匪丙&#x27;</span>,</span><br><span class="line">                phone:<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">                email:<span class="string">&#x27;123@123456.com&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name:<span class="string">&#x27;流氓丁&#x27;</span>,</span><br><span class="line">                phone:<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">                email:<span class="string">&#x27;123@123456.com&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">        <span class="comment">// 列标题</span></span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">&#x27;&lt;tr&gt;&lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;电话&lt;/td&gt;&lt;td&gt;邮箱&lt;/td&gt;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">        <span class="comment">// 循环遍历，每行加入tr标签，每个单元格加td标签</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; jsonData.length ; i++ )&#123;</span><br><span class="line">            str+=<span class="string">&#x27;&lt;tr&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> jsonData[i])&#123;</span><br><span class="line">                <span class="comment">// 增加\t为了不让表格显示科学计数法或者其他格式</span></span><br><span class="line">                str+=<span class="string">`&lt;td&gt;<span class="subst">$&#123; jsonData[i][key] + <span class="string">&#x27;\t&#x27;</span>&#125;</span>&lt;/td&gt;`</span>;     </span><br><span class="line">            &#125;</span><br><span class="line">            str+=<span class="string">&#x27;&lt;/tr&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Worksheet名</span></span><br><span class="line">        <span class="keyword">const</span> worksheet = <span class="string">&#x27;Sheet1&#x27;</span></span><br><span class="line">        <span class="keyword">const</span> uri = <span class="string">&#x27;data:application/vnd.ms-excel;base64,&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 下载的表格模板数据</span></span><br><span class="line">        <span class="keyword">const</span> template = <span class="string">`&lt;html xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; </span></span><br><span class="line"><span class="string">        xmlns:x=&quot;urn:schemas-microsoft-com:office:excel&quot; </span></span><br><span class="line"><span class="string">        xmlns=&quot;http://www.w3.org/TR/REC-html40&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;&lt;x:ExcelWorkbook&gt;&lt;x:ExcelWorksheets&gt;&lt;x:ExcelWorksheet&gt;</span></span><br><span class="line"><span class="string">		&lt;!-- 解决乱码问题 --&gt;</span></span><br><span class="line"><span class="string">		&lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;x:Name&gt;<span class="subst">$&#123;worksheet&#125;</span>&lt;/x:Name&gt;</span></span><br><span class="line"><span class="string">        &lt;x:WorksheetOptions&gt;&lt;x:DisplayGridlines/&gt;&lt;/x:WorksheetOptions&gt;&lt;/x:ExcelWorksheet&gt;</span></span><br><span class="line"><span class="string">        &lt;/x:ExcelWorksheets&gt;&lt;/x:ExcelWorkbook&gt;&lt;/xml&gt;&lt;![endif]--&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;&lt;body&gt;&lt;table&gt;<span class="subst">$&#123;str&#125;</span>&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;`</span>;</span><br><span class="line">        <span class="comment">// 下载模板</span></span><br><span class="line">        <span class="built_in">window</span>.location.href = uri + base64(template);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出base64编码</span></span><br><span class="line">    <span class="keyword">const</span> base64 = <span class="function"><span class="params">s</span> =&gt;</span> <span class="built_in">window</span>.btoa(<span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(s)));</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>


<h3 id="通过blob-推荐"><a href="#通过blob-推荐" class="headerlink" title="通过blob (推荐)"></a>通过blob (推荐)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端生成Excel表格并下载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fileName 文件名称(如：费用表)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>dataList 数据及表头list [[&quot;员工编号&quot;, &quot;员工姓名&quot;], [123, &quot;张三&quot;], [456, &quot;李四&quot;]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vc.createExcelByFrontNew = <span class="function"><span class="keyword">function</span> (<span class="params">fileName, dataList</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// csv转sheet对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">csv2sheet</span>(<span class="params">csv</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sheet = &#123;&#125;; <span class="comment">// 将要生成的sheet</span></span><br><span class="line">        csv = csv.split(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        csv.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">row, i</span>) </span>&#123;</span><br><span class="line">            row = row.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) sheet[<span class="string">&#x27;!ref&#x27;</span>] = <span class="string">&#x27;A1:&#x27;</span>+<span class="built_in">String</span>.fromCharCode(<span class="number">65</span>+row.length-<span class="number">1</span>)+(csv.length-<span class="number">1</span>);</span><br><span class="line">            row.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">col, j</span>) </span>&#123;</span><br><span class="line">                sheet[<span class="built_in">String</span>.fromCharCode(<span class="number">65</span>+j)+(i+<span class="number">1</span>)] = &#123;<span class="attr">v</span>: col&#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> sheet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个sheet转成最终的excel文件的blob对象，然后利用URL.createObjectURL下载</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sheet2blob</span>(<span class="params">sheet, sheetName</span>) </span>&#123;</span><br><span class="line">        sheetName = sheetName || <span class="string">&#x27;sheet1&#x27;</span>;</span><br><span class="line">        <span class="keyword">let</span> workbook = &#123;</span><br><span class="line">            SheetNames: [sheetName],</span><br><span class="line">            Sheets: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        workbook.Sheets[sheetName] = sheet;</span><br><span class="line">        <span class="comment">// 生成excel的配置项</span></span><br><span class="line">        <span class="keyword">let</span> wopts = &#123;</span><br><span class="line">            bookType: <span class="string">&#x27;xlsx&#x27;</span>, <span class="comment">// 要生成的文件类型</span></span><br><span class="line">            bookSST: <span class="literal">false</span>, <span class="comment">// 是否生成Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本IOS设备上有更好的兼容性</span></span><br><span class="line">            type: <span class="string">&#x27;binary&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> wbout = XLSX.write(workbook, wopts);</span><br><span class="line">        <span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([s2ab(wbout)], &#123;<span class="attr">type</span>:<span class="string">&quot;application/octet-stream&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">// 字符串转ArrayBuffer</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">s2ab</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(s.length);</span><br><span class="line">            <span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i!=s.length; ++i) view[i] = s.charCodeAt(i) &amp; <span class="number">0xFF</span>;</span><br><span class="line">            <span class="keyword">return</span> buf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> blob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用的打开下载对话框方法，没有测试过具体兼容性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>url 下载地址，也可以是一个blob对象，必选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>saveName 保存文件名，可选</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">openDownloadDialog</span>(<span class="params">url, saveName</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> url == <span class="string">&#x27;object&#x27;</span> &amp;&amp; url <span class="keyword">instanceof</span> Blob) &#123;</span><br><span class="line">            url = URL.createObjectURL(url); <span class="comment">// 创建blob地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> aLink = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        aLink.href = url;</span><br><span class="line">        aLink.download = saveName || <span class="string">&#x27;&#x27;</span>; <span class="comment">// HTML5新增的属性，指定保存文件名，可以不要后缀，注意，file:///模式下不会生效</span></span><br><span class="line">        <span class="keyword">let</span> event;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">window</span>.MouseEvent)</span><br><span class="line">            event = <span class="keyword">new</span> MouseEvent(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            event = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;MouseEvents&#x27;</span>);</span><br><span class="line">            event.initMouseEvent(<span class="string">&#x27;click&#x27;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="built_in">window</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        aLink.dispatchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入csv，执行后弹出下载框</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exportExcel</span>(<span class="params">csv</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sheet = csv2sheet(csv);</span><br><span class="line">        <span class="keyword">let</span> blob = sheet2blob(sheet);</span><br><span class="line">        openDownloadDialog(blob, <span class="string">&#x27;导出.xlsx&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// let aoa = [</span></span><br><span class="line">    <span class="comment">//     [&#x27;姓名&#x27;, &#x27;性别&#x27;, &#x27;年龄&#x27;, &#x27;注册时间&#x27;],</span></span><br><span class="line">    <span class="comment">//     [&#x27;张三&#x27;, &#x27;男&#x27;, 18, new Date()],</span></span><br><span class="line">    <span class="comment">//     [&#x27;李四&#x27;, &#x27;女&#x27;, 22, new Date()]</span></span><br><span class="line">    <span class="comment">// ];</span></span><br><span class="line">    <span class="keyword">let</span> sheet = XLSX.utils.aoa_to_sheet(dataList);</span><br><span class="line">    openDownloadDialog(sheet2blob(sheet), fileName ? (fileName + <span class="string">&quot;.xlsx&quot;</span>) : <span class="string">&#x27;导出.xlsx&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>实现</category>
      </categories>
      <tags>
        <tag>前端-实现</tag>
      </tags>
  </entry>
  <entry>
    <title>前端问题</title>
    <url>/2021/03/04/java/%E5%89%8D%E7%AB%AF/%E6%8A%A5%E9%94%99/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>-</p>
<a id="more"></a>

<h2 id="前端页面跳转与异步"><a href="#前端页面跳转与异步" class="headerlink" title="前端页面跳转与异步"></a>前端页面跳转与异步</h2><p>当发送一个异步请求后，若该请求尚未返回就进行页面跳转，此时即使请求返回也不会执行then中的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    url: <span class="string">&quot;localhost:8080/travle/news/list&quot;</span>,</span><br><span class="line">    data: &#123; <span class="attr">page</span>: $(<span class="string">&quot;#page&quot;</span>).val(), <span class="attr">limit</span>: <span class="number">5</span> &#125;,</span><br><span class="line">    dataType: <span class="string">&quot;JSON&quot;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  若页面跳转将不会进入then方法中</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">window</span>.location.href = url;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>问题</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端样式</title>
    <url>/2021/03/01/java/%E5%89%8D%E7%AB%AF/%E6%A0%B7%E5%BC%8F/%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Jquery修改样式"><a href="#Jquery修改样式" class="headerlink" title="Jquery修改样式"></a>Jquery修改样式</h2><!-- mroe -->

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.addInspectionListPoint&quot;</span>).css(&#123;</span><br><span class="line">    <span class="string">&quot;position&quot;</span>: <span class="string">&quot;relative&quot;</span>,</span><br><span class="line">    <span class="string">&quot;display&quot;</span>: <span class="string">&quot;inline-block&quot;</span>,</span><br><span class="line">    <span class="string">&quot;background&quot;</span>: <span class="string">&quot;#D0EEFF&quot;</span>,</span><br><span class="line">    <span class="string">&quot;border&quot;</span>: <span class="string">&quot;1px solid #99D3F5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;border-radius&quot;</span>: <span class="string">&quot;4px&quot;</span>,</span><br><span class="line">    <span class="string">&quot;padding&quot;</span>: <span class="string">&quot;4px 12px&quot;</span>,</span><br><span class="line">    <span class="string">&quot;overflow&quot;</span>: <span class="string">&quot;hidden&quot;</span>,</span><br><span class="line">    <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#1E88C7&quot;</span>,</span><br><span class="line">    <span class="string">&quot;text-decoration&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="string">&quot;text-indent&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;line-height&quot;</span>: <span class="string">&quot;20px&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="遮罩层"><a href="#遮罩层" class="headerlink" title="遮罩层"></a>遮罩层</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100%;</span><br><span class="line"><span class="selector-tag">height</span>: 100%;</span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">left</span>: 0;</span><br><span class="line"><span class="selector-tag">top</span>: 0;</span><br><span class="line"><span class="selector-tag">z-index</span>: 2;</span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-id">#000</span>;</span><br><span class="line"><span class="selector-tag">opacity</span>: 0.2;</span><br></pre></td></tr></table></figure>


<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>a标签去掉下划线</p>
</blockquote>
<p>text-decoration: none;</p>
<blockquote>
<p>去除页面默认边框</p>
</blockquote>
<p>html, body {</p>
<p>​    margin: 0;</p>
<p>​    padding: 0;</p>
<p>}</p>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>样式</category>
      </categories>
      <tags>
        <tag>前端-样式</tag>
      </tags>
  </entry>
  <entry>
    <title>js小数精度问题</title>
    <url>/2021/03/08/java/%E5%89%8D%E7%AB%AF/%E5%BA%95%E5%B1%82/js%E5%B0%8F%E6%95%B0%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="javascript表示小数的方法"><a href="#javascript表示小数的方法" class="headerlink" title="javascript表示小数的方法"></a>javascript表示小数的方法</h2><a id="more"></a>

<blockquote>
<h3 id="IEEE754标准表示方法："><a href="#IEEE754标准表示方法：" class="headerlink" title="IEEE754标准表示方法："></a>IEEE754标准表示方法：</h3></blockquote>
<p>​    单精度</p>
<p>​    双精度(64位)</p>
<p>​    延伸单精度</p>
<p>​    延伸双精度</p>
<p>​    <code>javascript 采用的是IEEE754的 双精度(64位)</code></p>
<p>​    64位意思为由0或1组成这64位</p>
<p>​    IEEE754将这64位分为三个部分</p>
<p><img src="image-20210308142017517.png" alt="image-20210308142017517"></p>
<p>​    </p>
<p>​    <code>科学计数法：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">666</span> 可表示为 <span class="number">6.66</span> * <span class="number">10</span>^<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">666000</span> 可表示为 <span class="number">6.66</span> * <span class="number">10</span>^<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>​    当数字越大的时候使用科学计数法可以节省更多的空间和时间，计算机也采用这种方式</p>
<p>​    使用计算机的科学计数法来表示24时，可以表示为：</p>
<p><img src="image-20210308142504637.png" alt="image-20210308142504637"></p>
<p>​    再结合IEEE754双精度（64位）</p>
<p><img src="image-20210308142838551.png" alt="image-20210308142838551"></p>
<p>​    </p>
<blockquote>
<h3 id="使用计算机的科学计数法表示小数"><a href="#使用计算机的科学计数法表示小数" class="headerlink" title="使用计算机的科学计数法表示小数"></a>使用计算机的科学计数法表示小数</h3><p><code>十进制转为二进制采用乘2取整法</code></p>
</blockquote>
<p><code>十进制  0.125</code></p>
<p>0.125 * 2 = <code>0</code>.25 整数部分为0</p>
<p>0.25 * 2 = <code>0</code>.5 整数部分为0</p>
<p>0.5 * 2 = <code>1</code> 整数部分为1</p>
<p><code>转化为二进制为 0.001</code></p>
<blockquote>
<h3 id="为什么JavaScript中0-1-0-2-不等于0-3"><a href="#为什么JavaScript中0-1-0-2-不等于0-3" class="headerlink" title="为什么JavaScript中0.1 + 0.2 不等于0.3"></a><code>为什么JavaScript中0.1 + 0.2 不等于0.3</code></h3></blockquote>
<p>十进制  0.1</p>
<p>0.1 * 2 = <code>0</code>.2 整数部分为0</p>
<p>0.2 * 2 = <code>0</code>.4 整数部分为0</p>
<p>0.8 * 2 = <code>1</code>.6 整数部分为1</p>
<p>0.6 * 2 = <code>1</code>.2 整数部分为1</p>
<p>0.2 * 2 = <code>0</code>.4 整数部分为0</p>
<p>……</p>
<p>转化为二进制为 0.0001100110（无限循环）</p>
<p><code>0.1 使用计算机科学计数法表示为 1.10011 * 2^-4</code></p>
<p>十进制  0.2</p>
<p>0.2 * 2 = <code>0</code>.4 整数部分为0</p>
<p>0.4 * 2 = <code>0</code>.8 整数部分为0</p>
<p>0.8 * 2 = <code>1</code>.6 整数部分为1</p>
<p>0.6 * 2 = <code>1</code>.2 整数部分为1</p>
<p>0.2 * 2 = <code>0</code>.4 整数部分为0</p>
<p>0.4 * 2 = <code>0</code>.8 整数部分为0</p>
<p>……</p>
<p>转化为二进制为 0.001100110（无限循环）</p>
<p><code>0.2 使用计算机科学计数法表示为 1.10011 * 2^-3</code></p>
<p><strong>即0.1与0.2使用计算机科学计数法表示时都是无限长的</strong></p>
<p><strong>而使用IEEE754的双精度(64位)来表示数字的话肯定会出现后续位置无法存储进去，因为指数位只有11位，有效数只有52位，有效位肯定无法存储这个无限长度的二进制数，这样就迫使计算机取一个近似的数字</strong></p>
<p><code>**因此0.1 + 0.2之后在转化为十进制时就已经不是纯正的0.3了**</code></p>
<blockquote>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3></blockquote>
<p>4前出现时会与3之间相隔很多个0</p>
<p><img src="image-20210308145541542.png" alt="image-20210308145541542"></p>
<p>因此可以使用四舍五入法</p>
<p>首先使用toFixed保留几位小数，然后使用parentFloat将其转化为小数</p>
<p><img src="image-20210308152532758.png" alt="image-20210308152532758"></p>
<p><img src="image-20210308152740791.png" alt="image-20210308152740791"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>底层</category>
      </categories>
      <tags>
        <tag>小数</tag>
      </tags>
  </entry>
  <entry>
    <title>日期操作</title>
    <url>/2021/03/17/java/%E5%89%8D%E7%AB%AF/%E9%80%BB%E8%BE%91/%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="获取每月最大的天数"><a href="#获取每月最大的天数" class="headerlink" title="获取每月最大的天数"></a>获取每月最大的天数</h2><p>获取2月最大天数：</p>
<p>new Date(2021, 2, 0).getDate();</p>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>逻辑</category>
      </categories>
      <tags>
        <tag>逻辑-日期操作</tag>
      </tags>
  </entry>
  <entry>
    <title>样式操作</title>
    <url>/2021/03/10/java/%E5%89%8D%E7%AB%AF/%E9%80%BB%E8%BE%91/%E6%A0%B7%E5%BC%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="原生获取节点并修改样式"><a href="#原生获取节点并修改样式" class="headerlink" title="原生获取节点并修改样式"></a>原生获取节点并修改样式</h2><a id="more"></a>

<h3 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h3><p>根据单一具体选择器获得（太过局限）</p>
<p><img src="image-20210310104658489.png" alt="image-20210310104658489"></p>
<p>根据组合选择器获得</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取第一个，返回单一Node节点，可直接执行节点操作</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;#promptMessage strong&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取全部，返回Node节点list，进行节点操作前需要筛选或遍历</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;#promptMessage strong&quot;</span>);</span><br></pre></td></tr></table></figure>


<h3 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取节点</span></span><br><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#promptMessage&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式修改 style</span></span><br><span class="line">element.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">element.style.width = <span class="string">&quot;300px&quot;</span>;</span><br><span class="line">element.style.backgroundColor = <span class="string">&quot;rgba(107, 100, 100, 0.5)&quot;</span>;</span><br><span class="line">element.style.left = e.pixel.x + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">element.style.top = e.pixel.y + <span class="number">50</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">element.style[<span class="string">&quot;font-weight&quot;</span>] = <span class="string">&quot;bold&quot;</span>;</span><br></pre></td></tr></table></figure>


<h2 id="修改文件上传框样式"><a href="#修改文件上传框样式" class="headerlink" title="修改文件上传框样式"></a>修改文件上传框样式</h2><p><img src="image-20210310153603689.png" alt="image-20210310153603689"></p>
<p><img src="image-20210310153541061.png" alt="image-20210310153541061"></p>
<h3 id="实现（上传Excel表格）"><a href="#实现（上传Excel表格）" class="headerlink" title="实现（上传Excel表格）"></a>实现（上传Excel表格）</h3><ol>
<li>使用a标签将input标签包裹</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;add&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span>选择文件<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line">	&lt;input type=<span class="string">&quot;file&quot;</span> @change=<span class="string">&quot;_uploadFile&quot;</span>&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>修改a标签样式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.add&quot;</span>).css(&#123;</span><br><span class="line">    <span class="string">&quot;position&quot;</span>: <span class="string">&quot;relative&quot;</span>,</span><br><span class="line">    <span class="string">&quot;display&quot;</span>: <span class="string">&quot;inline-block&quot;</span>,</span><br><span class="line">    <span class="string">&quot;background&quot;</span>: <span class="string">&quot;#D0EEFF&quot;</span>,</span><br><span class="line">    <span class="string">&quot;border&quot;</span>: <span class="string">&quot;1px solid #99D3F5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;border-radius&quot;</span>: <span class="string">&quot;4px&quot;</span>,</span><br><span class="line">    <span class="string">&quot;padding&quot;</span>: <span class="string">&quot;4px 12px&quot;</span>,</span><br><span class="line">    <span class="string">&quot;overflow&quot;</span>: <span class="string">&quot;hidden&quot;</span>,</span><br><span class="line">    <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#1E88C7&quot;</span>,</span><br><span class="line">    <span class="string">&quot;text-decoration&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="string">&quot;text-indent&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;line-height&quot;</span>: <span class="string">&quot;20px&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;.add input&quot;</span>).css(&#123;</span><br><span class="line">    <span class="string">&quot;font-size&quot;</span>: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">    <span class="string">&quot;position&quot;</span>: <span class="string">&quot;absolute&quot;</span>,</span><br><span class="line">    <span class="string">&quot;right&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;top&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;opacity&quot;</span>: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>事件代码</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_uploadFile (e) &#123;</span><br><span class="line">    <span class="comment">// 获取上传文件路径</span></span><br><span class="line">    <span class="keyword">let</span> filePath = e.path[<span class="number">0</span>].value;</span><br><span class="line">    <span class="keyword">let</span> dateList = [];</span><br><span class="line">    <span class="comment">// 文件格式判断</span></span><br><span class="line">    <span class="keyword">if</span>(filePath.indexOf(<span class="string">&quot;xlsx&quot;</span>)!==-<span class="number">1</span> || filePath.indexOf(<span class="string">&quot;xls&quot;</span>)!==-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> arr = filePath.split(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> fileName = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 文件名回显</span></span><br><span class="line">        $(<span class="string">&quot;.addInspectionListPointCheckFile em&quot;</span>).text(<span class="string">&quot;选择文件    &quot;</span> + fileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> files = e.target.files;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前端读取文件内容</span></span><br><span class="line">        <span class="keyword">let</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        fileReader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> workbook;</span><br><span class="line">            <span class="comment">// 存储获取到的数据</span></span><br><span class="line">            <span class="keyword">let</span> persons = [];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 以二进制流方式读取得到整份excel表格对象</span></span><br><span class="line">                <span class="keyword">let</span> data = ev.target.result;</span><br><span class="line">                workbook = XLSX.read(data, &#123;<span class="attr">type</span>: <span class="string">&#x27;binary&#x27;</span>&#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;文件类型不正确&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表格的表格范围，可用于判断表头是否数量是否正确</span></span><br><span class="line">            <span class="keyword">let</span> fromTo = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="comment">// 遍历每张表读取</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> sheet <span class="keyword">in</span> workbook.Sheets) &#123;</span><br><span class="line">                <span class="keyword">if</span> (workbook.Sheets.hasOwnProperty(sheet)) &#123;</span><br><span class="line">                    fromTo = workbook.Sheets[sheet][<span class="string">&#x27;!ref&#x27;</span>];</span><br><span class="line">                    <span class="comment">// console.log(fromTo);</span></span><br><span class="line">                    persons = persons.concat(XLSX.utils.sheet_to_json(workbook.Sheets[sheet]));</span><br><span class="line">                    <span class="comment">// 如果只取第一张表，就取消注释这行</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            vc.component._persons = persons;</span><br><span class="line">        &#125;;            </span><br><span class="line">        <span class="comment">// 以二进制方式打开文件</span></span><br><span class="line">        fileReader.readAsBinaryString(files[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;文件类型有误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>逻辑</category>
      </categories>
      <tags>
        <tag>逻辑-样式</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑</title>
    <url>/2021/03/10/java/%E5%89%8D%E7%AB%AF/%E9%80%BB%E8%BE%91/%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>mysql使用问题</title>
    <url>/2021/03/09/java/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="字符串类型字段排序问题"><a href="#字符串类型字段排序问题" class="headerlink" title="字符串类型字段排序问题"></a>字符串类型字段排序问题</h2><a id="more"></a>

<p>当使用类型为字符串的字段进行排序时</p>
<p><img src="image-20210309110431796.png" alt="image-20210309110431796"></p>
<p>会出现以较小数开头的大数排在较大数开头的小数前，如1999 和 2，1999排在2前</p>
<p><img src="image-20210309110605344.png" alt="image-20210309110605344"></p>
<p>原因为字符串类型字段进行比较时使用同一位的数字进行比较而不是转换成数字然后进行比较</p>
<p>==解决方法==</p>
<p>排序的字段后边加0，将字符串类型转换为数字类型再进行比较（ps：如此汉字的顺序可能会排到数字前边）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT * FROM floor ORDER BY floor_num + 0</span><br></pre></td></tr></table></figure>
<p><img src="image-20210309111032990.png" alt="image-20210309111032990"></p>
<h1 id="Duplicate-entry-‘id’-for-key-‘PRIMARY’"><a href="#Duplicate-entry-‘id’-for-key-‘PRIMARY’" class="headerlink" title="Duplicate entry ‘id’ for key ‘PRIMARY’"></a>Duplicate entry ‘id’ for key ‘PRIMARY’</h1><p>设置了id为主键，但是想要存入重复id</p>
<h2 id="数据库会冲突的字段"><a href="#数据库会冲突的字段" class="headerlink" title="数据库会冲突的字段"></a>数据库会冲突的字段</h2><p>describe</p>
<p>extends java关键字</p>
<h2 id="数据库记录浏览量"><a href="#数据库记录浏览量" class="headerlink" title="数据库记录浏览量"></a>数据库记录浏览量</h2><p>update <code>archives_storage</code> SET consult_num = consult_num + 1 where archives_id = “1002021031527330001”</p>
<h2 id="下划线类型-user-id-转小驼峰-userId"><a href="#下划线类型-user-id-转小驼峰-userId" class="headerlink" title="下划线类型(user_id)转小驼峰(userId)"></a>下划线类型(user_id)转小驼峰(userId)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">frontChange</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(list) || list.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> finalStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newFront = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> splitList = item.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">        splitList.forEach(<span class="function">(<span class="params">splitListItem, splitListIndex</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (splitListIndex != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> firstFront = splitListItem.trim().substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                splitListItem = splitListItem.replace(firstFront, firstFront.toUpperCase());</span><br><span class="line">            &#125;</span><br><span class="line">            newFront += splitListItem;</span><br><span class="line">        &#125;)</span><br><span class="line">        finalStr += newFront + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(finalStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>java</category>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>选择器</title>
    <url>/2021/03/05/java/%E5%89%8D%E7%AB%AF/%E6%A0%B7%E5%BC%8F/%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="选择最后一个对象"><a href="#选择最后一个对象" class="headerlink" title="选择最后一个对象"></a>选择最后一个对象</h2><a id="more"></a>

<p>#div a:last-child {</p>
<p>}</p>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>样式</category>
      </categories>
      <tags>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>redis使用</title>
    <url>/2021/03/12/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="redis清理缓存"><a href="#redis清理缓存" class="headerlink" title="redis清理缓存"></a>redis清理缓存</h2><a id="more"></a>

<p>客户端登录redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis.cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>


<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis.cli</span><br></pre></td></tr></table></figure>


<p>windows使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 查看数据条数 </span><br><span class="line">dbsize </span><br><span class="line"></span><br><span class="line">// 清空数据 </span><br><span class="line">flushall </span><br><span class="line"></span><br><span class="line">// 查看是否清空 </span><br><span class="line">keys *</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>java</category>
        <category>数据库</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis安装</title>
    <url>/2021/03/03/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/redis%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Linux安装redis"><a href="#Linux安装redis" class="headerlink" title="Linux安装redis"></a>Linux安装redis</h2><a id="more"></a>

<blockquote>
<h3 id="下载网址"><a href="#下载网址" class="headerlink" title="下载网址"></a>下载网址</h3></blockquote>
<p><a href="https://redis.io/download">https://redis.io/download</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>可选择下载好以后上传服务器，或直接使用命令：</p>
<p><code>wget http://download.redis.io/releases/redis-5.0.7.tar.gz</code></p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p><code>tar -zvxf redis-5.0.7.tar.gz</code></p>
<h4 id="移动redis目录"><a href="#移动redis目录" class="headerlink" title="移动redis目录"></a><strong>移动redis目录</strong></h4><p>一般都会将redis目录放置到 /usr/local/redis目录，所以这里输入下面命令将目前在/root目录下的redis-5.0.7文件夹更改目录，同时更改文件夹名称为redis。</p>
<p><code>mv /root/redis-5.0.7 /usr/local/redis</code></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a><strong>编译</strong></h4><p>cd到/usr/local/redis目录，输入命令make执行编译命令，接下来控制台会输出各种编译过程中输出的内容。</p>
<p><code>make</code></p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><strong>安装</strong></h4><p>输入以下命令</p>
<p><code>make PREFIX=/usr/local/redis install</code></p>
<blockquote>
<p>这里多了一个关键字 <strong>PREFIX=</strong> 这个关键字的作用是编译的时候用于指定程序存放的路径。比如我们现在就是指定了redis必须存放在/usr/local/redis目录。假设不添加该关键字Linux会将可执行文件存放在/usr/local/bin目录，库文件会存放在/usr/local/lib目录。配置文件会存放在/usr/local/etc目录。其他的资源文件会存放在usr/local/share目录。这里指定号目录也方便后续的卸载，后续直接rm -rf /usr/local/redis 即可删除redis。</p>
</blockquote>
<h4 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a><strong>启动redis</strong></h4><p>根据上面的操作已经将redis安装完成了。在目录/usr/local/redis 输入下面命令启动redis</p>
<p><code>./bin/redis-server&amp; ./redis.conf</code></p>
<p>上面的启动方式是采取后台进程方式，下面是采取显示启动方式(如在配置文件设置了daemonize属性为yes则跟后台进程方式启动其实一样)。</p>
<p><code>./bin/redis-server ./redis.conf</code></p>
<p>两种方式区别无非是有无带符号&amp;的区别。 redis-server 后面是配置文件，目的是根据该配置文件的配置启动redis服务。redis.conf配置文件允许自定义多个配置文件，通过启动时指定读取哪个即可。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>redis.conf配置文件</strong></p>
<p>在目录/usr/local/redis下有一个redis.conf的配置文件。我们上面启动方式就是执行了该配置文件的配置运行的。我么可以通过cat、vim、less等Linux内置的读取命令读取该文件。</p>
<p>也可以通过redis-cli命令进入redis控制台后通过CONFIG GET * 的方式读取所有配置项。 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">CONFIG GET *</span><br></pre></td></tr></table></figure>
<p><img src="image-20210303102754615.png" alt="image-20210303102754615"></p>
<p>回车确认后会将所有配置项读取出来，如下图</p>
<p><img src="2-1639211591.png" alt="img"></p>
<p>这里列举下比较重要的配置项</p>
<table>
<thead>
<tr>
<th>配置项名称</th>
<th>配置项值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>daemonize</td>
<td>yes、no</td>
<td>yes表示启用守护进程，默认是no即不以守护进程方式运行。其中Windows系统下不支持启用守护进程方式运行</td>
</tr>
<tr>
<td>port</td>
<td></td>
<td>指定 Redis 监听端口，默认端口为 6379</td>
</tr>
<tr>
<td>bind</td>
<td></td>
<td>绑定的主机地址,如果需要设置远程访问则直接将这个属性备注下或者改为bind * 即可,这个属性和下面的protected-mode控制了是否可以远程访问 。</td>
</tr>
<tr>
<td>protected-mode</td>
<td>yes 、no</td>
<td>保护模式，该模式控制外部网是否可以连接redis服务，默认是yes,所以默认我们外网是无法访问的，如需外网连接rendis服务则需要将此属性改为no。</td>
</tr>
<tr>
<td>timeout</td>
<td>300</td>
<td>当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能</td>
</tr>
<tr>
<td>loglevel</td>
<td>debug、verbose、notice、warning</td>
<td>日志级别，默认为 notice</td>
</tr>
<tr>
<td>databases</td>
<td>16</td>
<td>设置数据库的数量，默认的数据库是0。整个通过客户端工具可以看得到</td>
</tr>
<tr>
<td>rdbcompression</td>
<td>yes、no</td>
<td>指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大。</td>
</tr>
<tr>
<td>dbfilename</td>
<td>dump.rdb</td>
<td>指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td>dir</td>
<td></td>
<td>指定本地数据库存放目录</td>
</tr>
<tr>
<td>requirepass</td>
<td></td>
<td>设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td>
</tr>
<tr>
<td>maxclients</td>
<td>0</td>
<td>设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息。</td>
</tr>
<tr>
<td>maxmemory</td>
<td>XXX <bytes></td>
<td>指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区。配置项值范围列里XXX为数值。</td>
</tr>
</tbody></table>
<blockquote>
<p>这里我要将daemonize改为yes，不然我每次启动都得在redis-server命令后面加符号&amp;，不这样操作则只要回到Linux控制台则redis服务会自动关闭，同时也将bind注释，将protected-mode设置为no。</p>
<p>这样启动后我就可以在外网访问了。</p>
</blockquote>
<h3 id="查看Redis是否正在运行"><a href="#查看Redis是否正在运行" class="headerlink" title="查看Redis是否正在运行"></a><strong>查看Redis是否正在运行</strong></h3><h4 id="1、采取查看进程方式"><a href="#1、采取查看进程方式" class="headerlink" title="1、采取查看进程方式"></a><strong>1、采取查看进程方式</strong></h4><p><code>ps -aux | grep redis</code></p>
<p>结果如下图：</p>
<p><img src="0-1407665728.png" alt="img"></p>
<h4 id="2、采取端口监听查看方式"><a href="#2、采取端口监听查看方式" class="headerlink" title="2、采取端口监听查看方式"></a><strong>2、采取端口监听查看方式</strong></h4><p><code>netstat -lanp | grep 6379</code></p>
<p>结果如下图：</p>
<p><img src="1-1025164897.png" alt="img"></p>
<h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a><strong>redis-cli</strong></h3><p>redis-cli是连接本地redis服务的一个命令，通过该命令可以连接redis的脚本控制台。如下图</p>
<p><img src="5-1345838995.png" alt="img"></p>
<p>输入exit可以退出redis脚本控制台</p>
<h4 id="关闭运行中的Redis服务"><a href="#关闭运行中的Redis服务" class="headerlink" title="关闭运行中的Redis服务"></a><strong>关闭运行中的Redis服务</strong></h4><p>输入redis-cli 进入控制台后输入命令shutdown即可关闭运行中的Redis服务了。如下图:</p>
<p><img src="8-1051623110.png" alt="img"></p>
<h4 id="远程连接不上问题"><a href="#远程连接不上问题" class="headerlink" title="远程连接不上问题"></a><strong>远程连接不上问题</strong></h4><p>如下图，已经开放了Redis服务的ip不为127.0.0.1,理论上远程客户端应该可以连接了，而且云服务器的端口号也在安全组里开放了。</p>
<p><img src="57-703255053.png" alt="img"></p>
<h2 id="Windows安装redis"><a href="#Windows安装redis" class="headerlink" title="Windows安装redis"></a>Windows安装redis</h2><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3>]]></content>
      <categories>
        <category>java</category>
        <category>数据库</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库-redis</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/03/18/java/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="多线程基础："><a href="#多线程基础：" class="headerlink" title="多线程基础："></a>多线程基础：</h2><p><img src="image-20210318134058000.png" alt="image-20210318134058000"></p>
<h3 id="进程和线程："><a href="#进程和线程：" class="headerlink" title="进程和线程："></a>进程和线程：</h3><p>一个进程中可以有多个线程，一个进程中至少要有一条线程，该线程就是主线程</p>
<p>进程：进程就是所有的线程集合，是cpu的一个分配单元</p>
<p>线程：程序执行的路径，执行必须按照从上往下的顺序来执行，是进程中的一个执行单元</p>
<p>tips： 如果在多线程情况下，代码执行顺序就不是从上往下执行了</p>
<h3 id="多线程的好处："><a href="#多线程的好处：" class="headerlink" title="多线程的好处："></a>多线程的好处：</h3><p>同时且并行执行程序，提高程序效率</p>
<h3 id="多线程的应用场景："><a href="#多线程的应用场景：" class="headerlink" title="多线程的应用场景："></a>多线程的应用场景：</h3><p>对后端接口中比较耗时的代码可以采用多线程来实现（比如请求–qq通知–邮箱通知的场景）</p>
<p>异步实现日志的记录（单独开线程去进行日志的记录，不影响原有的代码）</p>
<p>意义：快速提升Http协议的响应，提升用户体验</p>
<p>抢票系统 ，秒杀业务</p>
<h3 id="后端开发为什么用到多线程？"><a href="#后端开发为什么用到多线程？" class="headerlink" title="后端开发为什么用到多线程？"></a>后端开发为什么用到多线程？</h3><p>http协议默认情况是采用同步的形式，采用多线程可以异步高效的执行程序</p>
<h3 id="如何理解多线程中的上下文切换："><a href="#如何理解多线程中的上下文切换：" class="headerlink" title="如何理解多线程中的上下文切换："></a>如何理解多线程中的上下文切换：</h3><p>CPU切换线程概念：</p>
<p>单核cpu的服务器中，开启多线程不是真正的多线程，因为单核cpu服务器在同一个时刻只能运行一个线程，只是运行的线程快速切换到另一个线程。cpu的核数越多，就越可以减少cpu的切换</p>
<h3 id="使用多线程有什么缺陷："><a href="#使用多线程有什么缺陷：" class="headerlink" title="使用多线程有什么缺陷："></a>使用多线程有什么缺陷：</h3><p>开启多个线程会导致cpu的不断切换，会耗费大量的cpu资源（cpu），影响服务器的性能</p>
<p>项目比较小可以采用多线程实现异步，</p>
<p>项目比较大的情况建议使用mq实现异步</p>
<h2 id="实现多线程的几种方式："><a href="#实现多线程的几种方式：" class="headerlink" title="实现多线程的几种方式："></a>实现多线程的几种方式：</h2><h3 id="继承Thread类："><a href="#继承Thread类：" class="headerlink" title="继承Thread类："></a>继承Thread类：</h3><ol>
<li><p>重写run（）方法，run方法里面就放的是要执行的代码</p>
</li>
<li><p>创建该线程实例</p>
</li>
<li><p>调用start方法</p>
</li>
</ol>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><ol>
<li><p>重写run（）方法，run方法里面就放的是要执行的代码</p>
</li>
<li><p>将实现接口的线程实例传递到新创建的线程中</p>
</li>
<li><p>调用start方法</p>
</li>
</ol>
<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>（本身是开了一个线程单独去处理业务实现多线程，但如果要获取其中的返回值内容，在主线程中其实就还是单线程了）</p>
<ol>
<li><p>重写call方法</p>
</li>
<li><p>主线程中将子线程传递到FutureTask中用来接收返回值</p>
</li>
<li><p>通过FutureTask对象可以开启线程和接收返回值</p>
</li>
</ol>
<h3 id="开线程池（常用）"><a href="#开线程池（常用）" class="headerlink" title="开线程池（常用）"></a>开线程池（常用）</h3><p>提供线程的复用机制，防止频繁的创建销毁线程，耗费系统资源</p>
<p>执行excute方法</p>
<h3 id="其他方式："><a href="#其他方式：" class="headerlink" title="其他方式："></a>其他方式：</h3><p>5.Spring中使用@Asyc注解来开启多线程，其实也是基于线程池进行了封装。单独开一个线程异步执行，达到快速响应用户请求的目的</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><p>用户登录请求过来，有多个业务要围绕该请求来执行，比如记录登录日志，发送短信通知，发送Email通知。通过使用注解异步去在后台执行这些操作，而在主线程中执行登录操作并直接返回成功，大大缩减了响应时间。但是如果想要拿到子线程中的返回结果，虽然是执行了异步的操作，但在主线程中就还是单线程同步的执行这些操作</p>
<h2 id="主线程-子线程-用户线程-守护线程的概念辨析："><a href="#主线程-子线程-用户线程-守护线程的概念辨析：" class="headerlink" title="主线程+子线程+用户线程+守护线程的概念辨析："></a>主线程+子线程+用户线程+守护线程的概念辨析：</h2><p>主线程就是main方法</p>
<p>子线程就是在主线程环境下的线程</p>
<p>用户线程+守护线程：是子线程的两种称呼</p>
<p>当主线程停止之后，用户线程不会随着主线程停止；守护线程则相反</p>
<p>默认创建线程都是用户线程，通过调用 threadxx.setDaemon(true)就可以变成守护线程，默认是false</p>
<p>守护线程场景：GC垃圾回收</p>
<h2 id="如何停止一个线程？"><a href="#如何停止一个线程？" class="headerlink" title="如何停止一个线程？"></a>如何停止一个线程？</h2><p>为什么不建议使用stop方法结束一个线程？</p>
<p>1.首先，如果使用stop方法会强制执行停止线程的操作，<strong>对于用户线程，本身可能还未执行完毕</strong>，强行停止可能会引发线程安全问题。这种方式不推荐，已经过时</p>
<p>2.场景：使用<code>volatile</code>关键字在类中创建一个私有为ture的变量，并配合一个更改变量为false方法a，然后在run方法进行while（true）循环。设置阻塞时间，阻塞时间一过，就会执行停止线程的自定义方法a，然后修改变量，停止线程。</p>
<p>（ps：volatile关键字：保证线程可见性，即子线程的执行状态被主线程观察到）</p>
<h2 id="多线程五种状态："><a href="#多线程五种状态：" class="headerlink" title="多线程五种状态："></a>多线程五种状态：</h2><p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B/clip_image003.jpg" alt="img"></p>
<p>《使用sleep代表将线程从运行状态变为阻塞状态，就是说将多个线程给堵死了，堵死的时间越久，线程之间的竞争就越激烈，出现脏读的概率就越大）》</p>
<h2 id="总结：好端端的程序为什么要用多线程呢？（多线程的好处？）"><a href="#总结：好端端的程序为什么要用多线程呢？（多线程的好处？）" class="headerlink" title="总结：好端端的程序为什么要用多线程呢？（多线程的好处？）"></a>总结：好端端的程序为什么要用多线程呢？（多线程的好处？）</h2><p>为了提高http协议响应速度，给用户比较友好的体验</p>
<p>对于web开发而言，使用多线程 的一个重要目的就是异步去处理业务，快速响应用户的请求，给用户良好的体验</p>
<h2 id="多线程之间如何实现同步（玩的是线程和线程之间问题的出现和解决）："><a href="#多线程之间如何实现同步（玩的是线程和线程之间问题的出现和解决）：" class="headerlink" title="多线程之间如何实现同步（玩的是线程和线程之间问题的出现和解决）："></a>多线程之间如何实现同步（玩的是线程和线程之间问题的出现和解决）：</h2><p>如何定义线程安全问题？</p>
<p>线程安全问题，其实这里由三个概念：</p>
<p>1.线程不安全：操作并非原子，多线程环境下执行一段代码，如果这段代码的结果受到多线程执行前后（时序）的影响，这些多线程会发生竞争的状态，此时就是线程不安全。</p>
<p>2.线程安全：多个线程去访问某个类的时候（可以是对这个类中属性的增删改之类的操作），如果这个类表现出我们预期会出现的行为，那么就可以称为是线程安全的。</p>
<p>3.我们常说的“解决线程安全”问题，其实说的是由“非预期的状态—&gt;转化为—-&gt;预期的状态”。</p>
<h3 id="1-线程安全问题是什么？（线程安全问题在什么场景下发生？）"><a href="#1-线程安全问题是什么？（线程安全问题在什么场景下发生？）" class="headerlink" title="1.线程安全问题是什么？（线程安全问题在什么场景下发生？）"></a>1.线程安全问题是什么？（线程安全问题在什么场景下发生？）</h3><p>例子：</p>
<p>多个线程—同时—共享—同一个全局变量—做 写 操作，线程与线程之间就会互相干扰，那么就导致了线程安全问题</p>
<p>场景：秒杀项目中，库存为1的情况下，两个用户都进行了下单操作，下单业务的两个线程同时都会获取到库存=1的产量，执行完之后就会发现超卖了，就是库存已经没有了但是其中一个用户还是下单成功了。这就是线程安全问题的出现</p>
<h3 id="2-怎么解决线程安全问题："><a href="#2-怎么解决线程安全问题：" class="headerlink" title="2.怎么解决线程安全问题："></a>2.怎么解决线程安全问题：</h3><p>思想：让多个线程在同一时刻只有一个线程执行。这个时候，在多线程与多线程之间，就成为了排队的状态，也就是单线程。注意这里的单线程说的是在线程和线程所在的空间。</p>
<p>那既然已经变成了单线程，为什么还要使用多线程呢？</p>
<p>注意，这里说的单线程是在多线程环境下，线程与线程之间有序进行，防止线程不安全</p>
<p>这里说的多线程是相对主线程来说的 ，使用多线程可以保证异步处理请求，快速响应用户请求。</p>
<p>做法：加锁，保证线程执行的有序性。但是会让程序的执行效率降低</p>
<h2 id="Lock锁-Synchronized锁-cas无锁"><a href="#Lock锁-Synchronized锁-cas无锁" class="headerlink" title="Lock锁/Synchronized锁/cas无锁"></a>Lock锁/Synchronized锁/cas无锁</h2><h3 id="3-Synchronized锁："><a href="#3-Synchronized锁：" class="headerlink" title="3.Synchronized锁："></a>3.Synchronized锁：</h3><p>思想：多个线程执行同一个方法的时候，必须要获取锁，拿到锁之后才可以执行该方法</p>
<p>场景：多个线程环境下，a线程拿到锁之后，b就一直在阻塞等待，这个时候的syn就是悲观锁的存在（可以把悲观锁理解为一种抽象状态）；等a执行完毕之后，才会将锁释放，这个时候b和其他线程开始竞争，去获取锁拿到执行权，因此b不是一定会拿到锁</p>
<p>用法：</p>
<p>加Synchronized就一定可以保证线程安全问题嘛？</p>
<p>不一定，两个场景：</p>
<p> 1.在单例模式中不加双重校验会导致重复创建两个实例，一个线程在释放锁之后另一个线程立马拿到锁去创建对象，如果不加一层判断的话会重复创建对象，所以要在其他线程拿到锁之后再加一层判断，也就是第二层非空判断</p>
<p> 2.火车站售票的场景中，会导致超卖</p>
<p><strong><em>*</em>\</strong>*<em>*</em>*<em>*</em>*<em>*</em>*<em>*</em>*<em>*</em>*<em>*</em>*<em>*</em>*<em>***</em></p>
<h3 id="4-Synchronized的三种使用方式："><a href="#4-Synchronized的三种使用方式：" class="headerlink" title="4.Synchronized的三种使用方式："></a>4.Synchronized的三种使用方式：</h3><p>1.用在方法（代码块）上作为关键字 = = this锁</p>
<p><img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B/clip_image005.png" alt="img"></p>
<p>\2. 用在静态方法（静态代码块）上作为关键字 = = 当前类的class作为锁</p>
<p>3.Object锁</p>
<p><strong><em>*</em>\</strong>*<em>*</em>*<em>*</em>*<em>*</em>*<em>*</em>*<em>*</em>*<em>*</em>*<em>*</em>*<em>***</em></p>
<h3 id="5-Lock锁重入与读写锁的用法"><a href="#5-Lock锁重入与读写锁的用法" class="headerlink" title="5.Lock锁重入与读写锁的用法"></a>5.Lock锁重入与读写锁的用法</h3><p>Lock锁：一个接口，接口中定义了自己的方法声明，lock和unlock方法</p>
<p>同时它有几个实现类，就是下面的重入锁和读写锁</p>
<p>两种锁：重入锁（ReentrantLock）和读写锁(ReadLock和WriteLock)</p>
<p>重入锁：实例化重入锁，调用lock和unlock方法自由控制锁的获取和释放</p>
<p>读写锁：包含读读锁，读写锁，写写锁</p>
<p>读读锁：</p>
<p>特点：读读共享</p>
<p>概念：多个线程同步开始，同步结束，多线程之间 同时共享要执行的代码</p>
<p>写写锁：</p>
<p>特点：写写互斥</p>
<p>概念：多线程之间互斥，线程排队，变成单线程，解决线程安全问题</p>
<p>读写锁：</p>
<p>特点：先写后读，写写之间互斥，读读之间共享</p>
<p>上面如果仅仅使用读写锁只是先写后读，而不能实现边写边读。想要实现 边写边读，就要使用wait和notify的方法，wait和notify用来实现多线程之间的通讯</p>
<p>6.如何实现多线程之间的通讯？</p>
<p>场景：生产者消费者模型，有一个全局的共享变量，要保证先写后读。通过条件判断语句结合wait和notify实现通讯（比如在生产者中加默认为false的判断，代表还没有写，此时消费者使用wait，释放锁并交给生产者，生产者执行完之后更改为true，并执行notify，此时消费者被唤醒然后执行），保证线程执行的有序性。</p>
<p>wait：</p>
<p>概念：让当前线程放弃cpu执行权，将锁释放（如果不释放锁就一直持有该锁，生产者没办法拿到锁进行写的操作，）。当前线程由运行状态变成阻塞状态</p>
<p>注意：要用在object类上</p>
<p>notify：等到生产者执行完毕之后，消费者再唤醒，进行读的操作</p>
<p>7.Synchronized锁和Lock锁的区别？</p>
<p>Synchronized时java中内置的关键字，在程序执行完毕或者程序抛出异常的时候会自动释放锁。自动挡</p>
<p>Lock锁可以人为控制锁的获取和释放，扩展性高。手动挡</p>
<p>8.如何理解锁的可重入性</p>
<p>概念：同一个线程中的同一把锁时可以传递的，就是锁的可重入性。syn和lock锁在设计时都有可重入性。可以防止死锁的产生</p>
<p>场景：在run（）方法中，run（）方法调用a（）方法，a方法调用b方法，a和b都是加锁的，都是this锁（即代表run方法的代码块上），那么这个时候a获取到锁并执行完毕之后会将锁传递给b，避免了死锁的产生</p>
<p>9.多线程死锁产生的原因</p>
<p>概念：多线程场景下，锁中嵌套锁，这两个锁都是不同的锁</p>
<p>场景：在多线程场景下，有两种不同的锁，比如Object锁和this 锁，线程a需要线程b的锁，线程b需要线程a的锁，但是这两个线程在未执行完毕的情况下都不会释放各自的锁，这样就导致了死锁的产生</p>
<p>解决死锁的一种方案：</p>
<p>超时放弃：</p>
<p>当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，放弃使用内置锁</p>
<p>使用Lock接口中的tryLock方法， 该方法可以按照固定时长等待锁。 因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。</p>
<p>10.join（）方法的使用：</p>
<p>场景：在主线程中有多个子线程，共同执行run方法，使用线程1.join（）就代表将主线程阻塞（相当于wait），同时主线程将锁释放，等待线程1拿到锁并执行完毕之后，主线程唤醒，主线程才能继续执行，然后调用其他子线程</p>
<p>注意：调用join方法代表join所在的线程进行阻塞，而不是调用join方法的线程</p>
<p>wait就相当于告诉主线程，你等一会儿，我先来执行，然后执行完毕之后，主线程唤醒</p>
<p>概念：保证线程的顺序问题，底层时wait和notify</p>
<p>Others：</p>
<p>1.yield()方法的作用是放弃当前线程获取CPU的执行权，将让其它的线程去获取。告诉cpu，先不用管我，但是cpu不忍心，还是会有机会执行它。给线程加yield（）的目的是为了让其他线程得到更多的执行机会。比如实际开发中某个线程是不太紧急的线程。</p>
<p>\2. 线程安全：一般通过加锁解决安全问题，保证数据一致性。一般我们可以使用synchronized标记方法或者代码块，来保证原子性操作。但是synchronized性能不如volatile。 在java底层中一些设计线程安全的源码都是用了volatile关键字。多线程如果要保证数据安全必须要保证原子性、可见性以及有序性。一般情况下当多个线程同时执行时，如果多个线程同时访问同一变量，如果变量所在方法没有使用synchronized，将导致每个线程只关注自己线程内cache的变量值，当多个线程将变量同步到主线程的主存时，会发生数据不一致的情况。如果使用volatile可以让变量拥有可见性，多个线程进行执行时，每个线程都会看到主线程中的主存的变量值发生的改变，进行修正，保证与自己线程数据同步，在线程修改变量时，volatile关键字会强制将修改的值立即写入主存，其他线程中的对应缓存变量就会被强制标记为无效，而从主存中进行同步。</p>
<p>项目业务场景：</p>
<p>   批量页面静态化 在系统中，商品详情页我们使用freemarker来进行页面静态化，每天夜里12点开始要对所有商品页面进行一遍静态化，由于商品数量比较多 如果使用单线程将耗时过长，我们使用一个定长线程池进行批量执行，将任务放在队列中，多个线程同时领取并执行。</p>
<p>订单处理（用户下单后可能支付状态不明确，我们后台可以通过多线程去主动核实第三方支付状态，来更新我们系统的订单状态）</p>
<p>登录后用户信息处理(用户登录后应该通知各相关系统将用户常用数据进行缓存 以快速响应登录用户)</p>
<p><a href="https://blog.csdn.net/renwei289443/article/details/79540809?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-2-79540809.nonecase">https://blog.csdn.net/renwei289443/article/details/79540809?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-2-79540809.nonecase</a></p>
<p>对于锁的理解，宏观来讲，原子的世界中，不管是在java代码中，还是在数据库中，还是在分布式系统中的微服务与微服务之间，只要是多个线程/事务/进程涉及到对数据的并发（同时）操作（增删改），都避免不了要使用锁来保证数据的一致性。锁要解决的问题，就是如何把一个并发的问题来变成一个串行的问题。使用合适的锁，是为了在保证串行的前提下，再保证一定的性能。</p>
<p>1.java代码中：多个线程同时操作同一个资源的情况</p>
<p>2.数据库中：多个事务去同时处理同一个数据</p>
<p>3.分布式中：多个进程（jvm）去操作同一个资源</p>
<p><strong><em>多线程相关\</em></strong></p>
<p><strong>”**</strong>锁“：**</p>
<p><a href="https://blog.csdn.net/renwei289443/article/details/79540809?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-2-79540809.nonecase"><strong>https://blog.csdn.net/renwei289443/article/details/79540809?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2<del>all</del>first_rank_v2~rank_v25-2-79540809.nonecase</strong></a></p>
<p>多线程场景执行原理：</p>
<p>主存中的值–线程复制，拿到自己的工作空间–处理–返回并赋值到主存中值</p>
<p>悲观锁有哪些劣势？</p>
<p>1.阻塞和唤醒对性能的开销较大</p>
<p>2.永久阻塞，就是如果当前线程内部执行发生死锁，无限循环，会导致死锁，永远不会释放锁，导致其他线程永远没办法获取锁，造成永久阻塞的情况</p>
<p>3.优先级，如果阻塞线程的优先级比较高，而持有锁的优先级比较低，就会引发优先级反转的问题</p>
<p>什么是悲观锁？什么是乐观锁？</p>
<p>悲观锁：</p>
<p>悲观的认为如果我不锁这这个对象，其他线程就会过来抢，就可能会对数据的结果造成错误，为了结果的正确性。因此在一个线程过来修改数据的时候，悲观锁就会锁住，不让其他线程访问。（数据锁住，然后改，其他人不能访问）</p>
<p>synchronized和lock都是悲观锁</p>
<p>乐观锁：</p>
<p>乐观的认为</p>
<p>实现：cas算法/版本号控制</p>
<p>悲观锁的场景：</p>
<p>Git：push代码到仓库，如果发现陈push的时候报错说版本不一致，就说明我们当前的版本不是最新的，已经有人提交过代码了，这个时候我们要先把项目拉取下来，然后再进行push；如果版本一致的话就可以直接进行push。</p>
<p>数据库：select * xxx for update加的就是一个悲观锁</p>
<p>开销对比：</p>
<p>悲观锁的原始开销要大于乐观锁</p>
<p>什么时候用悲观锁？什么时候用乐观锁？</p>
<p>乐观锁：并发情况下。读&gt;写，就是大多数情况都是读</p>
<p>悲观锁：并发情况下。写&gt;读，就是适合大部分都是写的情况下</p>
<p>ThreadLocal：</p>
<p>ThreadLocal面试题：</p>
<p><a href="https://www.cnblogs.com/jiangxinlingdu/p/11055540.html">https://www.cnblogs.com/jiangxinlingdu/p/11055540.html</a></p>
<p>ThreadLocal源码学习：</p>
<p><a href="https://blog.csdn.net/sinat_33921105/article/details/103295070?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-5.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-5.nonecase">https://blog.csdn.net/sinat_33921105/article/details/103295070?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-5.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-5.nonecase</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>后端</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>碰撞</title>
    <url>/2021/03/03/java/%E5%89%8D%E7%AB%AF/%E5%AE%9E%E7%8E%B0/%E7%A2%B0%E6%92%9E/</url>
    <content><![CDATA[<h2 id="JavaScript-游戏开发：手把手实现碰撞物理引擎"><a href="#JavaScript-游戏开发：手把手实现碰撞物理引擎" class="headerlink" title="JavaScript 游戏开发：手把手实现碰撞物理引擎"></a>JavaScript 游戏开发：手把手实现碰撞物理引擎</h2><a id="more"></a>

<p>转载自：<a href="https://blog.csdn.net/fengqiuzhihua/article/details/114156010">https://blog.csdn.net/fengqiuzhihua/article/details/114156010</a></p>
<blockquote>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>基础结构<br>绘制小球<br>移动小球<br>重构代码<br>碰撞检测<br>边界碰撞<br>向量的基本操作<br>碰撞处理<br>动量守恒定律<br>动能守恒定律<br>非弹性碰撞<br>重力<br>总结</p>
</blockquote>
<h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><p>这里使用 canvas 来实现 JavaScript 物理引擎。首先准备项目的基础文件和样式，新建一个 index.html、index.js 和 style.css 文件，分别用于编写 canvas 的 html 结构、引擎代码和画布样式。</p>
<p>在 index.html 的 <head /> 标签中引入样式文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;./style.css&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>


<p>在 <body /> 中，添加 canvas 元素、加载 index.js 文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;main&gt;</span><br><span class="line">  &lt;canvas id=<span class="string">&quot;gameboard&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/main&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;./index.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>这段代码定义了 id 为 gameboard 的 <canvas /> 元素，并放在了 <main /> 元素下， <main /> 元素主要是用来设置背景色和画布大小。在 <main/> 元素的下方引入 index.js 文件，这样可以在 DOM 加载完成之后再执行 JS 中的代码。</p>
<p>style.css 中的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  padding: <span class="number">0</span>;</span><br><span class="line">  margin: <span class="number">0</span>;</span><br><span class="line">  font-family: sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">main &#123;</span><br><span class="line">  width: 100vw;</span><br><span class="line">  height: 100vh;</span><br><span class="line">  background: hsl(0deg, <span class="number">0</span>%, <span class="number">10</span>%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样式很简单，去掉所有元素的外边距、内间距，并把 <main/> 元素的宽高设置为与浏览器可视区域相同，背景色为深灰色。</p>
<blockquote>
<p>hsl(hue, saturation, brightness) 为 css 颜色表示法之一，参数分别为色相，饱和度和亮度</p>
</blockquote>
<h3 id="绘制小球"><a href="#绘制小球" class="headerlink" title="绘制小球"></a>绘制小球</h3><p>接下来绘制小球，主要用到了 canvas 相关的 api。</p>
<p>在 index.js 中，编写如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;gameboard&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">canvas.width = <span class="built_in">window</span>.innerWidth;</span><br><span class="line">canvas.height = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> width = canvas.width;</span><br><span class="line"><span class="keyword">let</span> height = canvas.height;</span><br><span class="line"></span><br><span class="line">ctx.fillStyle = <span class="string">&quot;hsl(170, 100%, 50%)&quot;</span>;</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>

<p>代码中主要利用了二维 context 进行绘图操作：</p>
<ul>
<li>通过 canvas 的 id 获取 canvas 元素对象。</li>
<li>通过 canvas 元素对象获取绘图 context， getContext() 需要一个参数，用于表明是绘制 2d 图像，还是使用 webgl 绘制 3d 图象，这里选择 2d。context 就类似是一支画笔，可以改变它的颜色和绘制基本的形状。</li>
<li>给 canvas 的宽高设置为浏览器可视区域的宽高，并保存到 width 和 height 变量中方便后续使用。</li>
<li>给 context 设置颜色，然后调用 beginPath() 开始绘图。</li>
<li>使用 arc() 方法绘制圆形，它接收 5 个参数，前两个为圆心的 x、y 坐标，第 3 个为半径长度， 第 4 个和第 5 个分别是起始角度和结束角度，因为 arc() 其实是用来绘制一段圆弧，这里让它画一段 0 到 360 度的圆弧，就形成了一个圆形。这里的角度是使用 radian 形式表示的，0 到 360 度可以用 0 到 2 * Math.PI 来表示。</li>
<li>最后使用 ctx.fill() 给圆形填上颜色。</li>
</ul>
<p>这样就成功的绘制了一个圆形，我们在这把它当作一个小球：</p>
<h3 id="移动小球"><a href="#移动小球" class="headerlink" title="移动小球"></a>移动小球</h3><p>不过，这个时候的小球还是静止的，如果想让它移动，那么得修改它的圆心坐标，具体修改的数值则与运动速度有关。在移动小球之前，先看一下 canvas 进行动画的原理：</p>
<p>Canvas 进行动画的原理与传统的电影胶片类似，在一段时间内，绘制图像、更新图像位置或形状、清除画布，重新绘制图像，当在 1 秒内连续执行 60 次或以上这样的操作时，即以 60 帧的速度，就可以产生连续的画面。</p>
<p>那么在 JavaScript 中，浏览器提供了 window.requestAnimationFrame() 方法，它接收一个回调函数作为参数，每一次执行回调函数就相当于 1 帧动画，我们需要通过递归或循环连续调用它，浏览器会尽可能的在 1 秒内执行 60 次回调函数。那么利用它，我们就可以对 canvas 进行重绘，以实现小球的移动效果。</p>
<blockquote>
<p>由于 <code>window.requestAnimationFrame() </code>的调用基本是持续进行的，所以我们也可以把它称为游戏循环（Game loop）。</p>
</blockquote>
<p>接下来我们来看如何编写动画的基础结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(process);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(process);</span><br></pre></td></tr></table></figure>


<p>这里的 <code>process()</code> 函数就是 1 秒钟要执行 60 次的回调函数，每次执行完毕后继续调用 <code>window.requestAnimationFrame(process)</code>进行下一次循环。如果要移动小球，那么就需要把绘制小球和修改圆心 x、y 坐标的代码写到 <code>process()</code> 函数中。</p>
<p>为了方便更新坐标，我们把小球的圆心坐标保存到变量中，以方便对它们进行修改，然后再定义两个新的变量，分别表示在 x 轴方向上的速度 <code>vx</code>，和 y 轴方向上的速度<code> vy</code>，然后把 context 相关的绘图操作放到 <code>process()</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> vx = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> vy = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ctx.fillStyle = <span class="string">&quot;hsl(170, 100%, 50%)&quot;</span>;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.arc(x, y, <span class="number">60</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">  ctx.fill();</span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(process);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(process);</span><br></pre></td></tr></table></figure>

<p>要计算圆心坐标 x、y 的移动距离，我们需要速度和时间，速度这里有了， 那么时间要怎么获取呢？ <code>window.requestAnimationFrame() </code>会把当前时间的毫秒数（即时间戳）传递给回调函数，我们可以把本次调用的时间戳保存起来，然后在下一次调用时计算出执行这 1 帧动画消耗了多少秒，然后根据这个秒数和 x、y 轴方向上的速度去计算移动距离，分别加到 x 和 y 上，以获得最新的位置。注意这里的时间是上一次函数调用和本次函数调用的时间间隔，并不是第 1 次函数调用到当前函数调用总共过去了多少秒，所以相当于是时间增量，需要在之前 x 和 y 的值的基础上进行相加，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> startTime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">now</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!startTime) &#123;</span><br><span class="line">    startTime = now;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> seconds = (now - startTime) / <span class="number">1000</span>;</span><br><span class="line">  startTime = now;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新位置</span></span><br><span class="line">  x += vx * seconds;</span><br><span class="line">  y += vy * seconds;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除画布</span></span><br><span class="line">  ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">  <span class="comment">// 绘制小球</span></span><br><span class="line">  ctx.fillStyle = <span class="string">&quot;hsl(170, 100%, 50%)&quot;</span>;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.arc(x, y, <span class="number">60</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">  ctx.fill();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.requestAnimationFrame(process);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>process() </code>现在接收当前时间戳作为参数，然后做了下面这些操作：</p>
<p>计算上次函数调用与本次函数调用的时间间隔，以秒计，记录本次调用的时间戳用于下一次计算。<br>根据 x、y 方向上的速度，和刚刚计算出来的时间，计算出移动距离。<br>调用<code> clearRect()</code> 清除矩形区域画布，这里的参数，前两个是左上角坐标，后两个是宽高，把 canvas 的宽高传进去就会把整个画布清除。<br>重新绘制小球。<br>现在小球就可以移动了!</p>
<p>重构代码<br>上边的代码适合只有一个小球的情况，如果有多个小球需要绘制，就得编写大量重复的代码，这时我们可以把小球抽象成一个类，里边有绘图、更新位置等操作，还有坐标、速度、半径等属性，重构后的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">context, x, y, r, vx, vy</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">        <span class="built_in">this</span>.vx = vx;</span><br><span class="line">        <span class="built_in">this</span>.vy = vy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制小球</span></span><br><span class="line">    <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context.fillStyle = <span class="string">&quot;hsl(170, 100%, 50%)&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.context.beginPath();</span><br><span class="line">        <span class="built_in">this</span>.context.arc(<span class="built_in">this</span>.x, <span class="built_in">this</span>.y, <span class="built_in">this</span>.r, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">        <span class="built_in">this</span>.context.fill();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新画布</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">seconds</span></span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params">seconds</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x += <span class="built_in">this</span>.vx * seconds;</span><br><span class="line">        <span class="built_in">this</span>.y += <span class="built_in">this</span>.vy * seconds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里边的代码跟之前的一样，这里就不再赘述了，需要注意的是，Circle 类的 context 画笔属性是通过构造函数传递进来的，更新位置的代码放到了 <code>update() </code>方法中。</p>
<p>对于整个 canvas 的绘制过程，也可以抽象成一个类，当作是游戏或引擎控制器，例如把它放到一个叫 Gameboard 的类中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gameboard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.startTime;</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.circles = [</span><br><span class="line">            <span class="keyword">new</span> Circle(ctx, <span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">12</span>, <span class="number">25</span>),</span><br><span class="line">            <span class="keyword">new</span> Circle(ctx, <span class="number">180</span>, <span class="number">180</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">45</span>),</span><br><span class="line">        ];</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(<span class="built_in">this</span>.process.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">process</span>(<span class="params">now</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.startTime) &#123;</span><br><span class="line">            <span class="built_in">this</span>.startTime = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> seconds = (now - <span class="built_in">this</span>.startTime) / <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">this</span>.startTime = now;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.circles.length; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.circles[i].update(seconds);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.circles.length; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.circles[i].draw(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(<span class="built_in">this</span>.process.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Gameboard();</span><br></pre></td></tr></table></figure>

<p>在 Gameboard 类中：</p>
<ul>
<li>startTime 保存了上次函数执行的时间戳的属性，放到了构造函数中。</li>
<li>init() 方法创建了一个 circles 数组，里边放了两个示例的小球，这里先不涉及碰撞问题。然后调用 window.requestAnimationFrame() 开启动画。注意这里使用了 bind() 来把 Gameboard 的 this 绑定到回调函数中，以便于访问 Gameboard 中的方法和属性。</li>
<li>process() 方法也写到了这里边，每次执行时会遍历小球数组，对每个小球进行位置更新，然后清除画布，再重新绘制每个小球。</li>
<li>最后初始化 Gameboard 对象就可以开始执行动画了。</li>
</ul>
<p>这个时候有两个小球在移动了。</p>
<p>碰撞检测<br>为了实现仿真的物理特性，多个物体间碰撞会有相应的反应，第一步就是要先检测碰撞。我们先再多加几个小球，以便于碰撞的发生，在 Gameboard 类的 init() 方法中再添加几个小球：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.circles = [</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">30</span>, <span class="number">50</span>, <span class="number">30</span>, -<span class="number">100</span>, <span class="number">390</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">60</span>, <span class="number">180</span>, <span class="number">20</span>, <span class="number">180</span>, -<span class="number">275</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">120</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">120</span>, <span class="number">262</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">150</span>, <span class="number">180</span>, <span class="number">10</span>, -<span class="number">130</span>, <span class="number">138</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">190</span>, <span class="number">210</span>, <span class="number">10</span>, <span class="number">138</span>, -<span class="number">280</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">220</span>, <span class="number">240</span>, <span class="number">10</span>, <span class="number">142</span>, <span class="number">350</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">100</span>, <span class="number">260</span>, <span class="number">10</span>, <span class="number">135</span>, -<span class="number">460</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">120</span>, <span class="number">285</span>, <span class="number">10</span>, -<span class="number">165</span>, <span class="number">370</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">140</span>, <span class="number">290</span>, <span class="number">10</span>, <span class="number">125</span>, <span class="number">230</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">160</span>, <span class="number">380</span>, <span class="number">10</span>, -<span class="number">175</span>, -<span class="number">180</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">180</span>, <span class="number">310</span>, <span class="number">10</span>, <span class="number">115</span>, <span class="number">440</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">100</span>, <span class="number">310</span>, <span class="number">10</span>, -<span class="number">195</span>, -<span class="number">325</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">60</span>, <span class="number">150</span>, <span class="number">10</span>, -<span class="number">138</span>, <span class="number">420</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">70</span>, <span class="number">430</span>, <span class="number">45</span>, <span class="number">135</span>, -<span class="number">230</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">250</span>, <span class="number">290</span>, <span class="number">40</span>, -<span class="number">140</span>, <span class="number">335</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>然后给小球添加一个碰撞状态，在碰撞时，给两个小球设置为不同的颜色：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">context, x, y, r, vx, vy</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">    <span class="built_in">this</span>.colliding = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.context.fillStyle = <span class="built_in">this</span>.colliding</span><br><span class="line">      ? <span class="string">&quot;hsl(300, 100%, 70%)&quot;</span></span><br><span class="line">      : <span class="string">&quot;hsl(170, 100%, 50%)&quot;</span>;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来判断小球之间是否发生了碰撞，这个条件很简单，判断两个小球圆心的距离是否小于两个小球的半径之和就可以了，如果小于等于则发生了碰撞，大于则没有发生碰撞。圆心的距离即计算两个坐标点的距离，可以用公式：</p>
<p><img src="image-20210305094325289.png" alt="image-20210305094325289"></p>
<p>x1、y1 和 x2、y2 分别两个小球的圆心坐标。在比较时，可以对半径和进行平方运算，进而省略对距离的开方运算，也就是可以用下方的公式进行比较：</p>
<p><img src="image-20210305094345815.png" alt="image-20210305094345815"></p>
<p>r1 和 r2 为两球的半径。</p>
<p>在 Circle 类中，先添加一个isCircleCollided(other)方法，接收另一个小球对象作为参数，返回比较结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">isCircleCollided</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> squareDistance =</span><br><span class="line">      (<span class="built_in">this</span>.x - other.x) * (<span class="built_in">this</span>.x - other.x) +</span><br><span class="line">      (<span class="built_in">this</span>.y - other.y) * (<span class="built_in">this</span>.y - other.y);</span><br><span class="line">  <span class="keyword">let</span> squareRadius = (<span class="built_in">this</span>.r + other.r) * (<span class="built_in">this</span>.r + other.r);</span><br><span class="line">  <span class="keyword">return</span> squareDistance &lt;= squareRadius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>再添加 checkCollideWith(other) 方法，调用 isCircleCollided(other) 判断碰撞后，把两球的碰撞状态设置为 true：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">checkCollideWith</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.isCircleCollided(other)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.colliding = <span class="literal">true</span>;</span><br><span class="line">    other.colliding = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要使用双循环两两比对小球是否发生了碰撞，由于小球数组存放在 Gameboard 对象中，我们给它添加一个 checkCollision() 方法来检测碰撞：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">checkCollision</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 重置碰撞状态</span></span><br><span class="line">  <span class="built_in">this</span>.circles.forEach(<span class="function">(<span class="params">circle</span>) =&gt;</span> (circle.colliding = <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.circles.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">this</span>.circles.length; j++) &#123;</span><br><span class="line">      <span class="built_in">this</span>.circles[i].checkCollideWith(<span class="built_in">this</span>.circles[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为小球在碰撞后就应立即弹开，所以我们一开始要把所有小球的碰撞状态设置为 false，之后在循环中，对每个小球进行检测。这里注意到内层循环是从 i + 1 开始的，这是因为在判断 1 球和 2 球是否碰撞后，就无须再判断 2 球 和 1 球了。</p>
<p>之后在 process() 方法中，执行检测，注意检测应该发生在使用 for 循环更新小球位置的后边才准确：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.circles.length; i++) &#123;</span><br><span class="line">  <span class="built_in">this</span>.circles[i].update(seconds);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.checkCollision();</span><br></pre></td></tr></table></figure>

<p>现在，可以看到小球在碰撞时，会改变颜色了。</p>
<h3 id="边界碰撞"><a href="#边界碰撞" class="headerlink" title="边界碰撞"></a>边界碰撞</h3><p>上边的代码在执行之后，小球都会穿过边界跑到外边去，那么我们先处理一下边界碰撞的问题。检测边界碰撞需要把四个面全部都处理到，根据圆心坐标和半径来判断是否和边界发生了碰撞。例如跟左边界发生碰撞时，圆心的 x 坐标是小于或等于半径长度的，而跟右边界发生碰撞时，圆心 x 坐标应该大于或等于画布最右侧坐标（即宽度值）减去半径的长度。上边界和下边界类似，只是使用圆心 y 坐标和画布的高度值。在水平方向上（即左右边界）发生碰撞时，小球的运动方向发生改变，只需要把垂直方向上的速度 vy 值取反即可，在垂直方向上碰撞则把 vx 取反。</p>
<p><img src="image-20210305094746518.png" alt="image-20210305094746518"></p>
<p>现在看一下代码的实现，在 Gameboard 类中添加一个 checkEdgeCollision() 方法，根据上边描述的规则编写如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">checkEdgeCollision</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.circles.forEach(<span class="function">(<span class="params">circle</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 左右墙壁碰撞</span></span><br><span class="line">        <span class="keyword">if</span> (circle.x &lt; circle.r) &#123;</span><br><span class="line">            circle.vx = -circle.vx;</span><br><span class="line">            circle.x = circle.r;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (circle.x &gt; width - circle.r) &#123;</span><br><span class="line">            circle.vx = -circle.vx;</span><br><span class="line">            circle.x = width - circle.r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上下墙壁碰撞</span></span><br><span class="line">        <span class="keyword">if</span> (circle.y &lt; circle.r) &#123;</span><br><span class="line">            circle.vy = -circle.vy;</span><br><span class="line">            circle.y = circle.r;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (circle.y &gt; height - circle.r) &#123;</span><br><span class="line">            circle.vy = -circle.vy;</span><br><span class="line">            circle.y = height - circle.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在代码中，碰撞时，除了对速度进行取反操作之外，还把小球的坐标修改为紧临边界，防止超出。接下来在 process() 中添加对边界碰撞的检测：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.checkEdgeCollision();</span><br><span class="line"><span class="built_in">this</span>.checkCollision();</span><br></pre></td></tr></table></figure>


<p>这时候可以看到小球在碰到边界时，可以反弹了</p>
<p>但是小球间的碰撞还没有处理，在处理之前，先复习一下向量的基本操作，数学好的同学可以直接跳过，只看相关的代码。</p>
<p>向量的基本操作<br>由于在碰撞时，需要对速度向量（或称为矢量）进行操作，向量是使用类似坐标的形式表示的，例如 &lt; 3, 5 &gt; (这里用 &lt;&gt; 表示向量)，它有长度和方向，对于它的运算有一定的规则，本教程中需要用到向量的加法、减法、乘法、点乘和标准化操作。</p>
<p>向量相加只需要把两个向量的 x 坐标和 y 坐标相加即可，例如：<code>&lt; 3 , 5 &gt; + &lt; 1 , 2 &gt; = &lt; 4 , 7 &gt;</code><br>减法与加法类似，把 x 坐标和 y 坐标相减，例如：<code>&lt; 3 , 5 &gt; − &lt; 1 , 2 &gt; = &lt; 2 , 3 &gt;</code></p>
<p>乘法，这里指的是向量和标量的乘法，标量指的就是普通的数字，结果是把 x 和 y 分别和标量相乘，例如：<code>3 × &lt; 3 , 5 &gt; = &lt; 9 , 15 &gt; </code></p>
<p>点乘是两个向量相乘的一种方式，类似的还有叉乘，但是在本示例中用不到，点乘其实计算的是一个向量在另一个向量上的投影，它的计算方式为两个向量的 x 的积加上 y 的积，它返回的是一个标量，即第 1 个向量在第 2 个向量上投影的长度，例如：<code>&lt; 3 , 5 &gt; ⋅ &lt; 1 , 2 &gt; = 3 × 1 + 5 × 2 = 13 </code></p>
<p>标准化是除掉向量的长度，只剩下方向，这样的向量它的长度为 1，称为单位向量，标准化的过程是让 x 和 y 分别除以向量的长度，因为向量表示的是和原点(0, 0)的距离，所以可以直接使用 </p>
<p><img src="image-20210305095015781.png" alt="image-20210305095015781"><br>  计算长度，例如 &lt; 3, 4 &gt; 标准化后的结果为：<code>&lt; 3 , 5 &gt; ⋅ &lt; 1 , 2 &gt; = 3 × 1 + 5 × 2 = 13</code>。</p>
<p>了解了向量的基本运算后，我们来创建一个 Vector 工具类，来方便我们进行向量的运算，它的代码就是实现了这些运算规则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 向量加法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Vector&#125;</span> <span class="variable">v</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(<span class="built_in">this</span>.x + v.x, <span class="built_in">this</span>.y + v.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 向量减法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Vector&#125;</span> <span class="variable">v</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">substract</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(<span class="built_in">this</span>.x - v.x, <span class="built_in">this</span>.y - v.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 向量与标量乘法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Vector&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">multiply</span>(<span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(<span class="built_in">this</span>.x * s, <span class="built_in">this</span>.y * s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 向量与向量点乘（投影）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Vector&#125;</span> <span class="variable">v</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">dot</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x * v.x + <span class="built_in">this</span>.y * v.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   * 向量标准化（除去长度）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">distance</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">normalize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> distance = <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.x * <span class="built_in">this</span>.x + <span class="built_in">this</span>.y * <span class="built_in">this</span>.y);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(<span class="built_in">this</span>.x / distance, <span class="built_in">this</span>.y / distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中没有什么特殊的语法和操作，这里就不再赘述了，接下来我们看一下小球的碰撞问题。</p>
<h3 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h3><p>碰撞处理最主要的部分就是计算碰撞后的速度和方向。通常最简单的碰撞问题是在同一个水平面上的两个物体的碰撞，称为一维碰撞，因为此时只需要计算同一方向上的速度，而我们现在的程序小球是在一个二维平面内运动的，小球之间发生正面相碰（即在同一运动方向）的概率很小，大部分是斜碰（在不同运动方向上擦肩相碰），需要同时计算水平和垂直方向上的速度和方向，这就属于是二维碰撞问题。不过，其实小球之间的碰撞，只有在连心线（两个圆心的连线）上有作用力，而在碰撞接触的切线方向上没有作用力，那么我们只需要知道连心线方向的速度变化就可以了，这样就转换成了一维碰撞。</p>
<p><img src="image-20210305095122013.png" alt="image-20210305095122013"></p>
<p>计算碰撞后的速度时，遵守动量守恒定律和动能守恒定律，公式分别为：</p>
<h4 id="动量守恒定律"><a href="#动量守恒定律" class="headerlink" title="动量守恒定律"></a>动量守恒定律</h4><p><img src="image-20210305095144325.png" alt="image-20210305095144325"></p>
<h4 id="动能守恒定律"><a href="#动能守恒定律" class="headerlink" title="动能守恒定律"></a>动能守恒定律</h4><p><img src="image-20210305095158664.png" alt="image-20210305095158664"></p>
<p>m1、m2 分别为两小球的质量，v1 和 v2 为两小球碰撞前的速度向量，v1’ 和 v2’ 为碰撞后的速度向量。根据这两个公式可以推导出两小球碰撞后的速度公式：</p>
<p><img src="image-20210305095226329.png" alt="image-20210305095226329"></p>
<p>​    </p>
<p>如果不考虑小球的质量，或质量相同，其实就是两小球速度互换，即：</p>
<p><img src="image-20210305095244943.png" alt="image-20210305095244943"></p>
<p>这里我们给小球加上质量，然后套用公式来计算小球碰撞后速度，先在 Circle 类中给小球加上质量 mass 属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">context, x, y, r, vx, vy, mass = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">    <span class="built_in">this</span>.mass = mass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 Gameboard 类的初始化小球处，给每个小球添加质量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.circles = [</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">30</span>, <span class="number">50</span>, <span class="number">30</span>, -<span class="number">100</span>, <span class="number">390</span>, <span class="number">30</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">60</span>, <span class="number">180</span>, <span class="number">20</span>, <span class="number">180</span>, -<span class="number">275</span>, <span class="number">20</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">120</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">120</span>, <span class="number">262</span>, <span class="number">100</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">150</span>, <span class="number">180</span>, <span class="number">10</span>, -<span class="number">130</span>, <span class="number">138</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">190</span>, <span class="number">210</span>, <span class="number">10</span>, <span class="number">138</span>, -<span class="number">280</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">220</span>, <span class="number">240</span>, <span class="number">10</span>, <span class="number">142</span>, <span class="number">350</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">100</span>, <span class="number">260</span>, <span class="number">10</span>, <span class="number">135</span>, -<span class="number">460</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">120</span>, <span class="number">285</span>, <span class="number">10</span>, -<span class="number">165</span>, <span class="number">370</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">140</span>, <span class="number">290</span>, <span class="number">10</span>, <span class="number">125</span>, <span class="number">230</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">160</span>, <span class="number">380</span>, <span class="number">10</span>, -<span class="number">175</span>, -<span class="number">180</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">180</span>, <span class="number">310</span>, <span class="number">10</span>, <span class="number">115</span>, <span class="number">440</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">100</span>, <span class="number">310</span>, <span class="number">10</span>, -<span class="number">195</span>, -<span class="number">325</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">60</span>, <span class="number">150</span>, <span class="number">10</span>, -<span class="number">138</span>, <span class="number">420</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">70</span>, <span class="number">430</span>, <span class="number">45</span>, <span class="number">135</span>, -<span class="number">230</span>, <span class="number">45</span>),</span><br><span class="line">  <span class="keyword">new</span> Circle(ctx, <span class="number">250</span>, <span class="number">290</span>, <span class="number">40</span>, -<span class="number">140</span>, <span class="number">335</span>, <span class="number">40</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>在 Circle 类中加上 <code>changeVelocityAndDirection(other)</code> 方法来计算碰撞后的速度，它接收另一个小球对象作为参数，同时计算这两个小球碰撞厚的速度和方向，这个是整个引擎的核心，我们一点一点的来看它是如何实现的。首先把两个小球的速度使用 Vector 向量来表示：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">changeVelocityAndDirection</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 创建两小球的速度向量</span></span><br><span class="line">   <span class="keyword">let</span> velocity1 = <span class="keyword">new</span> Vector(<span class="built_in">this</span>.vx, <span class="built_in">this</span>.vy);</span><br><span class="line">   <span class="keyword">let</span> velocity2 = <span class="keyword">new</span> Vector(other.vx, other.vy);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为我们本身就已经使用 vx 和 vy 来表示水平和垂直方向上的速度向量了，所以直接把它们传给 Vector 的构造函数就可以了。velocity1 和 velocity2 分别代表当前小球和碰撞小球的速度向量。</p>
<p>接下来获取连心线方向的向量，也就是两个圆心坐标的差：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vNorm = <span class="keyword">new</span> Vector(<span class="built_in">this</span>.x - other.x, <span class="built_in">this</span>.y - other.y);</span><br></pre></td></tr></table></figure>

<p>接下来获取连心线方向的单位向量和切线方向上的单位向量，这些单位向量代表的是连心线和切线的方向：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unitVNorm = vNorm.normalize();</span><br><span class="line"><span class="keyword">let</span> unitVTan = <span class="keyword">new</span> Vector(-unitVNorm.y, unitVNorm.x);</span><br></pre></td></tr></table></figure>


<p>unitVNorm 是连心线方向单位向量，unitVTan 是切线方向单位向量，切线方向其实就是把连心线向量的 x、y 坐标互换，并把 y 坐标取反。根据这两个单位向量，使用点乘计算小球速度在这两个方向上的投影：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v1n = velocity1.dot(unitVNorm);</span><br><span class="line"><span class="keyword">let</span> v1t = velocity1.dot(unitVTan);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v2n = velocity2.dot(unitVNorm);</span><br><span class="line"><span class="keyword">let</span> v2t = velocity2.dot(unitVTan);</span><br></pre></td></tr></table></figure>

<p>计算结果是一个标量，也就是没有方向的速度值。v1n 和 v1t 表示当前小球在连心线和切线方向的速度值，v2n 和 v2t 则表示的是碰撞小球 的速度值。在计算出两小球的速度值之后，我们就有了碰撞后的速度公式所需要的变量值了，直接用代码把公式套用进去：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v1nAfter = (v1n * (<span class="built_in">this</span>.mass - other.mass) + <span class="number">2</span> * other.mass * v2n) / (<span class="built_in">this</span>.mass + other.mass);</span><br><span class="line"><span class="keyword">let</span> v2nAfter = (v2n * (other.mass - <span class="built_in">this</span>.mass) + <span class="number">2</span> * <span class="built_in">this</span>.mass * v1n) / (<span class="built_in">this</span>.mass + other.mass);</span><br></pre></td></tr></table></figure>

<p>v1nAfter 和 v2nAfter 分别是两小球碰撞后的速度，现在可以先判断一下，如果 v1nAfter 小于 v2nAfter，那么第 1 个小球和第 2 个小球会越来越远，此时不用处理碰撞：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (v1nAfter &lt; v2nAfter) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再给碰撞后的速度加上方向，计算在连心线方向和切线方向上的速度，只需要让速度标量跟连心线单位向量和切线单位向量相乘：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> v1VectorNorm = unitVNorm.multiply(v1nAfter);</span><br><span class="line"><span class="keyword">let</span> v1VectorTan = unitVTan.multiply(v1t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v2VectorNorm = unitVNorm.multiply(v2nAfter);</span><br><span class="line"><span class="keyword">let</span> v2VectorTan = unitVTan.multiply(v2t);</span><br></pre></td></tr></table></figure>

<p>这样有了两个小球连心线上的新速度向量和切线方向上的新速度向量，最后把连心线上的速度向量和切线方向的速度向量进行加法操作，就能获得碰撞后小球的速度向量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> velocity1After = v1VectorNorm.add(v1VectorTan);</span><br><span class="line"><span class="keyword">let</span> velocity2After = v2VectorNorm.add(v2VectorTan);</span><br></pre></td></tr></table></figure>

<p>之后我们把向量中的 x 和 y 分别还原到小球的 vx 和 vy 属性中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.vx = velocity1After.x;</span><br><span class="line"><span class="built_in">this</span>.vy = velocity1After.y;</span><br><span class="line"></span><br><span class="line">other.vx = velocity2After.x;</span><br><span class="line">other.vy = velocity2After.y;</span><br></pre></td></tr></table></figure>

<p>最后在 checkCollideWith() 方法的 if 语句中调用此方法，即在检测到碰撞时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">checkCollideWith</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.isCircleCollided(other)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.colliding = <span class="literal">true</span>;</span><br><span class="line">    other.colliding = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.changeVelocityAndDirection(other); <span class="comment">// 在这里调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，小球的碰撞效果就实现了。</p>
<h3 id="非弹性碰撞"><a href="#非弹性碰撞" class="headerlink" title="非弹性碰撞"></a>非弹性碰撞</h3><p>现在小球之间的碰撞属于完全弹性碰撞，即碰撞之后不会有能量损失，这样小球永远不会停止运动，我们可以让小球在碰撞之后损失一点能量，来模拟更真实的物理效果。要让小球碰撞后有能量损失，可以使用恢复系数，它是一个取值范围为 0 到 1 的数值，每次碰撞后，乘以它就可以减慢速度，如果恢复系数为 1 则为完全弹性碰撞，为 0 则是完全非弹性碰撞，之间的数值为非弹性碰撞，现实生活中的碰撞都是非弹性碰撞。</p>
<p>先看一下边界碰撞，这个比较简单，假设边界的恢复系数为 0.8，然后在每次对速度取反的时候乘以它就可以了，把 Gameboard checkEdgeCollision()方法作如下改动：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">checkEdgeCollision</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cor = <span class="number">0.8</span>;                  <span class="comment">// 设置恢复系统</span></span><br><span class="line">  <span class="built_in">this</span>.circles.forEach(<span class="function">(<span class="params">circle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 左右墙壁碰撞</span></span><br><span class="line">    <span class="keyword">if</span> (circle.x &lt; circle.r) &#123;</span><br><span class="line">      circle.vx = -circle.vx * cor; <span class="comment">// 加上恢复系数</span></span><br><span class="line">      circle.x = circle.r;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (circle.x &gt; width - circle.r) &#123;</span><br><span class="line">      circle.vx = -circle.vx * cor; <span class="comment">// 加上恢复系数</span></span><br><span class="line">      circle.x = width - circle.r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下墙壁碰撞</span></span><br><span class="line">    <span class="keyword">if</span> (circle.y &lt; circle.r) &#123;</span><br><span class="line">      circle.vy = -circle.vy * cor; <span class="comment">// 加上恢复系数</span></span><br><span class="line">      circle.y = circle.r;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (circle.y &gt; height - circle.r) &#123;</span><br><span class="line">      circle.vy = -circle.vy * cor; <span class="comment">// 加上恢复系数</span></span><br><span class="line">      circle.y = height - circle.r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来设置小球的恢复系数，给 Circle 类再加上一个恢复系数 cor 属性，每个小球可以设置不同的数值，来让它们有不同的弹性，然后在初始化小球时设置随意的恢复系数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">context, x, y, r, vx, vy, mass = <span class="number">1</span>, cor = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 其它代码</span></span><br><span class="line">    <span class="built_in">this</span>.cor = cor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gameboard</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.circles = [</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">30</span>, <span class="number">50</span>, <span class="number">30</span>, -<span class="number">100</span>, <span class="number">390</span>, <span class="number">30</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">60</span>, <span class="number">180</span>, <span class="number">20</span>, <span class="number">180</span>, -<span class="number">275</span>, <span class="number">20</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">120</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">120</span>, <span class="number">262</span>, <span class="number">100</span>, <span class="number">0.3</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">150</span>, <span class="number">180</span>, <span class="number">10</span>, -<span class="number">130</span>, <span class="number">138</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">190</span>, <span class="number">210</span>, <span class="number">10</span>, <span class="number">138</span>, -<span class="number">280</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">220</span>, <span class="number">240</span>, <span class="number">10</span>, <span class="number">142</span>, <span class="number">350</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">100</span>, <span class="number">260</span>, <span class="number">10</span>, <span class="number">135</span>, -<span class="number">460</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">120</span>, <span class="number">285</span>, <span class="number">10</span>, -<span class="number">165</span>, <span class="number">370</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">140</span>, <span class="number">290</span>, <span class="number">10</span>, <span class="number">125</span>, <span class="number">230</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">160</span>, <span class="number">380</span>, <span class="number">10</span>, -<span class="number">175</span>, -<span class="number">180</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">180</span>, <span class="number">310</span>, <span class="number">10</span>, <span class="number">115</span>, <span class="number">440</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">100</span>, <span class="number">310</span>, <span class="number">10</span>, -<span class="number">195</span>, -<span class="number">325</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">60</span>, <span class="number">150</span>, <span class="number">10</span>, -<span class="number">138</span>, <span class="number">420</span>, <span class="number">10</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">70</span>, <span class="number">430</span>, <span class="number">45</span>, <span class="number">135</span>, -<span class="number">230</span>, <span class="number">45</span>, <span class="number">0.7</span>),</span><br><span class="line">      <span class="keyword">new</span> Circle(ctx, <span class="number">250</span>, <span class="number">290</span>, <span class="number">40</span>, -<span class="number">140</span>, <span class="number">335</span>, <span class="number">40</span>, <span class="number">0.7</span>),</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上恢复系数之后，小球碰撞后的速度计算也需要改变一下，可以简单的让 v1nAfter 和 v2nAfter 乘以小球的恢复系数，也可以使用带有恢复系数的速度公式（这两种方式我暂时还不太清楚区别，有兴趣的小伙伴可以自己研究一下），公式如下：</p>
<p><img src="image-20210305095726505.png" alt="image-20210305095726505"></p>
<p>接着把公式转换为代码，在 Circle 类的 changeVelocityAndDirection() 方法中，替换掉 v1nAfter 和 v2nAfter 的计算公式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cor = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.cor, other.cor);</span><br><span class="line"><span class="keyword">let</span> v1nAfter =</span><br><span class="line">    (<span class="built_in">this</span>.mass * v1n + other.mass * v2n + cor * other.mass * (v2n - v1n)) /</span><br><span class="line">    (<span class="built_in">this</span>.mass + other.mass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v2nAfter =</span><br><span class="line">    (<span class="built_in">this</span>.mass * v1n + other.mass * v2n + cor * <span class="built_in">this</span>.mass * (v1n - v2n)) /</span><br><span class="line">    (<span class="built_in">this</span>.mass + other.mass);</span><br></pre></td></tr></table></figure>


<p>这里要注意的是两小球碰撞时的恢复系数应取两者的最小值，按照常识，弹性小的无论是去撞别人还是别人撞它，都会有同样的效果。现在小球碰撞后速度会有所减慢，不过还差一点，我们可以加上重力来让小球自然下落。</p>
<h3 id="重力"><a href="#重力" class="headerlink" title="重力"></a>重力</h3><p>添加重力比较简单，先在全局定义重力加速度常量，然后在小球更新垂直方向上的速度时，累计重力加速度就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gravity = <span class="number">980</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">seconds</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.vy += gravity * seconds; <span class="comment">// 重力加速度</span></span><br><span class="line">    <span class="built_in">this</span>.x += <span class="built_in">this</span>.vx * seconds;</span><br><span class="line">    <span class="built_in">this</span>.y += <span class="built_in">this</span>.vy * seconds;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>重力加速度大约是 <code>9.8 m / s 2 9.8m/s^29.8m/s </code><br> ，但是由于我们的画布是以象素为单位的，所以使用 9.8 看起来会像是没有重力，或者像是从很远的地方观察小球，这时候可以把重力加速度放大一定倍数来达到更逼真的效果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们这个简单的 JavaScript 物理引擎就完成了，实现了物理引擎最基本的部分，可以有一个完整的掉落和碰撞的效果，要做一个更逼真的物理引擎还需要考虑更多的因素和更复杂的公式，例如考虑一下摩擦力、空气阻力、碰撞后的旋转角度等，并且这个 canvas 的帧率也会有一定的问题，如果有的小球速度过快，但是如果来不及执行下一次回调函数更新它的位置，那么它可能就直接穿过碰撞的小球到另一边了。</p>
<p>来总结一下开发过程：</p>
<ul>
<li><p>使用 context 绘制小球。</p>
</li>
<li><p>搭建 Canvas 动画基础结构，主要使用 window.requestAnimationFrame方法反复执行回调函数。</p>
</li>
<li><p>移动小球，通过小球的速度和函数执行时的时间戳来计算移动距离。</p>
</li>
<li><p>碰撞检测，通过比对两个小球的距离和它们半径的和。</p>
</li>
<li><p>边界碰撞的检测和方向改变。</p>
</li>
<li><p>小球之间的碰撞，应用速度公式和向量操作计算出碰撞后的速度和方向。</p>
</li>
<li><p>利用恢复系数实现非弹性碰撞。</p>
</li>
<li><p>添加重力效果。<br>代码可以在以下地址中查看：</p>
<p><a href="https://github.com/zxuqian/html-css-examples/tree/master/35-collision-physics">https://github.com/zxuqian/html-css-examples/tree/master/35-collision-physics</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>前端</category>
        <category>实现</category>
      </categories>
      <tags>
        <tag>前端-实现</tag>
      </tags>
  </entry>
</search>
