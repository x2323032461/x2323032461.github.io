<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端报错汇总</title>
    <url>/2021/02/22/%E6%8A%A5%E9%94%99/%E5%89%8D%E7%AB%AF%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h3><p><strong>net::ERR_CONNECTION_REFUSED</strong></p>
<a id="more"></a>

<p>错误连接被拒绝</p>
<p>1，有可能是网络原因   2，有可能是请求地址错误</p>
<h3 id="错误码"><a href="#错误码" class="headerlink" title="错误码"></a>错误码</h3><p>4**</p>
<table>
<thead>
<tr>
<th>常用错误码</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>参数有误</td>
</tr>
<tr>
<td>401</td>
<td>需要进行身份认证</td>
</tr>
<tr>
<td>403</td>
<td>请求没问题，但是后台拒绝响应，可能为身份未认证或其他原因(后台可以告诉也可以不告诉)</td>
</tr>
<tr>
<td>404</td>
<td>资源无法找到</td>
</tr>
</tbody></table>
<p><strong>详细错误码</strong></p>
<table>
<thead>
<tr>
<th>错误码</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>400 Bad_Request</td>
<td>1. 语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求；2. 请求参数有误。</td>
</tr>
<tr>
<td>401 Unauthorized</td>
<td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>
</tr>
<tr>
<td>402 Payment Required</td>
<td>该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td>403 Forbidden</td>
<td>服务器已经理解请求，但是拒绝执行它，与401不同的是，401并不能提供任何帮助，而403如果这不是一个 HEAD 请求，服务器希望能够讲清楚为何请求不能被执行，那么就可以在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td>404 Not_Found</td>
<td>请求失败，请求所希望得到的资源未被在服务器上发现。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。</td>
</tr>
<tr>
<td>405 Method Not Allowed</td>
<td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>
</tr>
<tr>
<td>406 Not Acceptable</td>
<td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。  除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。<br />实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td>407 Proxy Authentication Required</td>
<td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。</td>
</tr>
<tr>
<td>408 Request Timeout</td>
<td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td>409 Conflict</td>
<td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<br />冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td>410 Gone</td>
<td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用<a href="https://baike.baidu.com/item/404%E7%8A%B6%E6%80%81%E7%A0%81/12678394">404状态码</a>。除非额外说明，否则这个响应是可缓存的。<br />410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td>411 Length Required</td>
<td>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td>412 Precondition Failed</td>
<td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td>413 Request Entity Too Large</td>
<td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br />如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td>414 Request-URI Too Long</td>
<td>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：<br />本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<br />重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。<br />客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生<a href="https://baike.baidu.com/item/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/678453">缓冲区溢出</a>，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>
</tr>
<tr>
<td>415 Unsupported Media Type</td>
<td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td>416 Requested Range Not Satisfiable</td>
<td>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。<br />假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td>417 Expectation Failed</td>
<td>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td>418 I’m a teapot</td>
<td></td>
</tr>
<tr>
<td>421 Misdirected Request</td>
<td>请求被指向到无法生成响应的服务器（比如由于连接重复使用）</td>
</tr>
<tr>
<td>422 Unprocessable Entity</td>
<td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>423 Locked</td>
<td>当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>424 Failed Dependency</td>
<td>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>425 Too Early</td>
<td>状态码 425 Too Early 代表服务器不愿意冒风险来处理该请求，原因是处理该请求可能会被“重放”，从而造成潜在的重放攻击。（RFC 8470） [1]</td>
</tr>
<tr>
<td>426 Upgrade Required</td>
<td>客户端应当切换到TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td>449 Retry With</td>
<td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
<tr>
<td>451 Unavailable For Legal Reasons</td>
<td>该请求因法律原因不可用。（RFC 7725）</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title>前端问题</title>
    <url>/2021/03/04/%E6%8A%A5%E9%94%99/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>-</p>
<a id="more"></a>

<h2 id="前端页面跳转与异步"><a href="#前端页面跳转与异步" class="headerlink" title="前端页面跳转与异步"></a>前端页面跳转与异步</h2><p>当发送一个异步请求后，若该请求尚未返回就进行页面跳转，此时即使请求返回也不会执行then中的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    url: <span class="string">&quot;localhost:8080/travle/news/list&quot;</span>,</span><br><span class="line">    data: &#123; <span class="attr">page</span>: $(<span class="string">&quot;#page&quot;</span>).val(), <span class="attr">limit</span>: <span class="number">5</span> &#125;,</span><br><span class="line">    dataType: <span class="string">&quot;JSON&quot;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  若页面跳转将不会进入then方法中</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">window</span>.location.href = url;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat</title>
    <url>/2021/02/25/%E8%BD%AF%E4%BB%B6/Navicat/</url>
    <content><![CDATA[<h2 id="Navicat快捷键"><a href="#Navicat快捷键" class="headerlink" title="Navicat快捷键"></a>Navicat快捷键</h2><a id="more"></a>

<blockquote>
<h4 id="执行选中的sql语句-run"><a href="#执行选中的sql语句-run" class="headerlink" title="执行选中的sql语句  run"></a>执行选中的sql语句  run</h4></blockquote>
<p>Ctrl + shift + R</p>
<blockquote>
<h4 id="执行窗口的sql语句"><a href="#执行窗口的sql语句" class="headerlink" title="执行窗口的sql语句"></a>执行窗口的sql语句</h4></blockquote>
<p>Ctrl + R</p>
<blockquote>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4></blockquote>
<p>Ctrl + /</p>
<blockquote>
<h4 id="解除注释"><a href="#解除注释" class="headerlink" title="解除注释"></a>解除注释</h4></blockquote>
<p>Ctrl + shift + /</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>单词</title>
    <url>/2021/03/05/%E8%BF%9B%E5%BA%A6/%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<p>method        方法</p>
<a id="more"></a>

<p>field             字段</p>
<p>parameter    参数</p>
<p>constructor    构造方法</p>
<p>local variable    局部变量</p>
<p>annotation    注解</p>
<p>package        包</p>
<p>generate        生成</p>
<p>deploy        部署</p>
<p>menu        菜单</p>
<p>category    类别</p>
<p>😱</p>
<p>tag             标签</p>
<p>destory        销毁</p>
<p>release         稳定版本  </p>
<p>debug         内部测试版本</p>
<p>exist          存在</p>
<p>component    组件</p>
<p>engine          引擎</p>
<p>schema        计划的提纲</p>
<p>studio             工作室</p>
<p>operation    log    操作 日志</p>
<p>middle          中部</p>
<p>concurrent      并发</p>
<p>arguments     论点</p>
<p>empty         空的</p>
<p>prototype      原型</p>
<p>instance        例子、实例</p>
<p>front         前面</p>
<p>common        常见的</p>
<p>community    社区</p>
<p>Annotation    注释、注解</p>
<p>configuration    配置</p>
<p>Suppress     抑制；镇压；废止 </p>
<p>Warnings        警告</p>
<p>declared        公开的</p>
<p>cycle        周期</p>
<p>destroy        销毁</p>
<p>tail            跟踪</p>
<p>detail        详情</p>
<p>Elastic         弹性</p>
<p>Search        搜索</p>
<p>stack        堆栈</p>
<p>Ranking        排名</p>
<p>addr            地址</p>
<p>Beats        心跳</p>
<p>kafka</p>
<p>broker        经纪人(服务器)</p>
<p>topic            主题</p>
<p>partition        分隔、隔断、分区</p>
<p>leader        领导</p>
<p>follower        跟随者</p>
<p>producer        生产者</p>
<p>consumer    消费者</p>
<p>cluster        集群</p>
<p>software        软件</p>
<p>unique        唯一</p>
<p>upper respiratory infection    上呼吸道感染</p>
<p>ELK</p>
<p>shard        切片，碎片</p>
<p>pretty        漂亮的，美观的</p>
<p>bulk            大量的</p>
<p>zookeeper</p>
<p>event        事件</p>
<p>access        访问</p>
<p>scheme        方案</p>
<p>valid            有效的</p>
<p>authentication    身份验证</p>
<p>await        等待</p>
<p>expire        期满，超时</p>
<p>cyclic        循环        sai ke lei ke </p>
<p>barrier        屏障        bai rui er</p>
<p>atomic        原子的</p>
<p>grep            正则表达式</p>
<p>transaction    事务</p>
<p>acquire        获取</p>
<p>release        释放</p>
<p>core            核心</p>
<p>current        现在的</p>
<p>observer        观察者</p>
<p>subject        主题</p>
<p>register        登记</p>
<p>notify        通知</p>
<p>arguments     论据、论点</p>
<p>site            网站</p>
<p>apologize     道歉</p>
<p>insult        侮辱</p>
<p>truth            真理</p>
<p>westerns        西部的  西方？</p>
<p>difference     不同</p>
<p>human rights    人权</p>
<p>How dare they    他们怎么敢</p>
<p>feel ashame    感到羞耻</p>
<p>tax             税收</p>
<p>technology    技术</p>
<p>splunk        si pu lan ke</p>
]]></content>
      <categories>
        <category>进度</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>进度</tag>
      </tags>
  </entry>
  <entry>
    <title>进度</title>
    <url>/2021/02/23/%E8%BF%9B%E5%BA%A6/%E8%BF%9B%E5%BA%A6/</url>
    <content><![CDATA[<p>​    <del>——</del></p>
<a id="more"></a>

<p>​    <del>git    2021-03-01</del></p>
<p>==docker   p7==</p>
<p>kafka</p>
<p>多线程详解</p>
<p>注解和反射</p>
<p>如何备战秋招</p>
<p>k8s-Kubernetes</p>
]]></content>
      <categories>
        <category>进度</category>
        <category>进度</category>
      </categories>
      <tags>
        <tag>进度</tag>
      </tags>
  </entry>
  <entry>
    <title>cron表达式</title>
    <url>/2021/02/25/java/%E5%89%8D%E5%90%8E%E7%AB%AF/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>　　<strong>一、结构</strong></p>
<p>　　corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份</p>
<p>​    <a id="more"></a></p>
<p>　　<strong>二、各字段的含义</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>允许值</th>
<th>允许的特殊字符</th>
</tr>
</thead>
<tbody><tr>
<td>秒（Seconds）</td>
<td>0~59的整数</td>
<td>, - * /   四个字符</td>
</tr>
<tr>
<td>分（<em>Minutes</em>）</td>
<td>0~59的整数</td>
<td>, - * /   四个字符</td>
</tr>
<tr>
<td>小时（<em>Hours</em>）</td>
<td>0~23的整数</td>
<td>, - * /   四个字符</td>
</tr>
<tr>
<td>日期（<em>DayofMonth</em>）</td>
<td>1~31的整数（但是你需要考虑你月的天数）</td>
<td>,- * ? / L W C   八个字符</td>
</tr>
<tr>
<td>月份（<em>Month</em>）</td>
<td>1~12的整数或者 JAN-DEC</td>
<td>, - * /   四个字符</td>
</tr>
<tr>
<td>星期（<em>DayofWeek</em>）</td>
<td>1~7的整数或者 SUN-SAT （1=SUN）</td>
<td>, - * ? / L C #   八个字符</td>
</tr>
<tr>
<td>年(可选，留空)（<em>Year</em>）</td>
<td>1970~2099</td>
<td>, - * /   四个字符</td>
</tr>
</tbody></table>
<p>　　<strong>注意事项：</strong></p>
<p>　　每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：</p>
<p>　　（1）<em>：表示匹配该域的任意值。假如在Minutes域使用</em>, 即表示每分钟都会触发事件。</p>
<p>　　（2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用<em>，如果使用</em>表示不管星期几都会触发，实际上并不是这样。</p>
<p>　　（3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 </p>
<p>　　（4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. </p>
<p>　　（5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 </p>
<p>　　（6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 </p>
<p>　　（7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。</p>
<p>　　（8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 </p>
<p>　　（9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。</p>
<p>　　<strong>三、常用表达式例子</strong></p>
<p>　　（1）<strong>0 0 2 1 * ? *</strong>  表示在每月的1日的凌晨2点调整任务</p>
<p>　　（2）<strong>0 15 10 ? * MON-FRI</strong>  表示周一到周五每天上午10:15执行作业</p>
<p>　　（3）<strong>0 15 10 ? 6L 2002-2006</strong>  表示2002-2006年的每个月的最后一个星期五上午10:15执行作</p>
<p>　　（4）<strong>0 0 10,14,16 * * ?</strong>  每天上午10点，下午2点，4点 </p>
<p>　　（5）<strong>0 0/30 9-17 * * ?</strong>  朝九晚五工作时间内每半小时 </p>
<p>　　（6）<strong>0 0 12 ? * WED</strong>   表示每个星期三中午12点 </p>
<p>　　（7）<strong>0 0 12 * * ?</strong>  每天中午12点触发 </p>
<p>　　（8）<strong>0 15 10 ? * *</strong>   每天上午10:15触发 </p>
<p>　　（9）<strong>0 15 10 * * ?</strong>   每天上午10:15触发 </p>
<p>　　（10）<strong>0 15 10 * * ? *</strong>   每天上午10:15触发 </p>
<p>　　（11）<strong>0 15 10 * * ? 2005</strong>   2005年的每天上午10:15触发 </p>
<p>　　（12）<strong>0 * 14 * * ?</strong>   在每天下午2点到下午2:59期间的每1分钟触发 </p>
<p>　　（13）<strong>0 0/5 14 * * ?</strong>   在每天下午2点到下午2:55期间的每5分钟触发 </p>
<p>　　（14）<strong>0 0/5 14,18 * * ?</strong>   在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </p>
<p>　　（15）<strong>0 0-5 14 * * ?</strong>   在每天下午2点到下午2:05期间的每1分钟触发 </p>
<p>　　（16）<strong>0 10,44 14 ? 3 WED</strong>   每年三月的星期三的下午2:10和2:44触发 </p>
<p>　　（17）<strong>0 15 10 ? * MON-FRI</strong>   周一至周五的上午10:15触发 </p>
<p>　　（18）<strong>0 15 10 15 * ?</strong>   每月15日上午10:15触发 </p>
<p>　　（19）<strong>0 15 10 L * ?</strong>   每月最后一日的上午10:15触发 </p>
<p>　　（20）<strong>0 15 10 ? * 6L</strong>   每月的最后一个星期五上午10:15触发 </p>
<p>　　（21）<strong>0 15 10 ? * 6L 2002-2005</strong>  2002年至2005年的每月的最后一个星期五上午10:15触发 </p>
<p>　　（22）<strong>0 15 10 ? * 6#3</strong>  每月的第三个星期五上午10:15触发</p>
<p>　　</p>
<p>　　<strong>注：</strong></p>
<p>　　（1）有些子表达式能包含一些范围或列表</p>
<p>　　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”</p>
<p>“*”字符代表所有可能的值</p>
<p>　　因此，“<em>”在子表达式（月）里表示每个月的含义，“</em>”在子表达式（天（星期））表示星期的每一天</p>
<p>　　“/”字符用来指定数值的增量<br>　　例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟<br>在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样</p>
<p>　　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值<br>　　当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”</p>
<p>　　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写<br>　　但是它在两个子表达式里的含义是不同的。<br>　　在天（月）子表达式中，“L”表示一个月的最后一天<br>　　在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT</p>
<p>　　如果在“L”前有具体的内容，它就具有其他的含义了</p>
<p>　　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五<br>　　注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>
]]></content>
      <tags>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>redis安装</title>
    <url>/2021/03/03/java/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Linux安装redis"><a href="#Linux安装redis" class="headerlink" title="Linux安装redis"></a>Linux安装redis</h2><blockquote>
<h3 id="下载网址"><a href="#下载网址" class="headerlink" title="下载网址"></a>下载网址</h3></blockquote>
<p><a href="https://redis.io/download">https://redis.io/download</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>可选择下载好以后上传服务器，或直接使用命令：</p>
<p><code>wget http://download.redis.io/releases/redis-5.0.7.tar.gz</code></p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p><code>tar -zvxf redis-5.0.7.tar.gz</code></p>
<h4 id="移动redis目录"><a href="#移动redis目录" class="headerlink" title="移动redis目录"></a><strong>移动redis目录</strong></h4><p>一般都会将redis目录放置到 /usr/local/redis目录，所以这里输入下面命令将目前在/root目录下的redis-5.0.7文件夹更改目录，同时更改文件夹名称为redis。</p>
<p><code>mv /root/redis-5.0.7 /usr/local/redis</code></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a><strong>编译</strong></h4><p>cd到/usr/local/redis目录，输入命令make执行编译命令，接下来控制台会输出各种编译过程中输出的内容。</p>
<p><code>make</code></p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><strong>安装</strong></h4><p>输入以下命令</p>
<p><code>make PREFIX=/usr/local/redis install</code></p>
<blockquote>
<p>这里多了一个关键字 <strong>PREFIX=</strong> 这个关键字的作用是编译的时候用于指定程序存放的路径。比如我们现在就是指定了redis必须存放在/usr/local/redis目录。假设不添加该关键字Linux会将可执行文件存放在/usr/local/bin目录，库文件会存放在/usr/local/lib目录。配置文件会存放在/usr/local/etc目录。其他的资源文件会存放在usr/local/share目录。这里指定号目录也方便后续的卸载，后续直接rm -rf /usr/local/redis 即可删除redis。</p>
</blockquote>
<h4 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a><strong>启动redis</strong></h4><p>根据上面的操作已经将redis安装完成了。在目录/usr/local/redis 输入下面命令启动redis</p>
<p><code>./bin/redis-server&amp; ./redis.conf</code></p>
<p>上面的启动方式是采取后台进程方式，下面是采取显示启动方式(如在配置文件设置了daemonize属性为yes则跟后台进程方式启动其实一样)。</p>
<p><code>./bin/redis-server ./redis.conf</code></p>
<p>两种方式区别无非是有无带符号&amp;的区别。 redis-server 后面是配置文件，目的是根据该配置文件的配置启动redis服务。redis.conf配置文件允许自定义多个配置文件，通过启动时指定读取哪个即可。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>redis.conf配置文件</strong></p>
<p>在目录/usr/local/redis下有一个redis.conf的配置文件。我们上面启动方式就是执行了该配置文件的配置运行的。我么可以通过cat、vim、less等Linux内置的读取命令读取该文件。</p>
<p>也可以通过redis-cli命令进入redis控制台后通过CONFIG GET * 的方式读取所有配置项。 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">CONFIG GET *</span><br></pre></td></tr></table></figure>
<p><img src="image-20210303102754615.png" alt="image-20210303102754615"></p>
<p>回车确认后会将所有配置项读取出来，如下图</p>
<p><img src="2-1639211591.png" alt="img"></p>
<p>这里列举下比较重要的配置项</p>
<table>
<thead>
<tr>
<th>配置项名称</th>
<th>配置项值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>daemonize</td>
<td>yes、no</td>
<td>yes表示启用守护进程，默认是no即不以守护进程方式运行。其中Windows系统下不支持启用守护进程方式运行</td>
</tr>
<tr>
<td>port</td>
<td></td>
<td>指定 Redis 监听端口，默认端口为 6379</td>
</tr>
<tr>
<td>bind</td>
<td></td>
<td>绑定的主机地址,如果需要设置远程访问则直接将这个属性备注下或者改为bind * 即可,这个属性和下面的protected-mode控制了是否可以远程访问 。</td>
</tr>
<tr>
<td>protected-mode</td>
<td>yes 、no</td>
<td>保护模式，该模式控制外部网是否可以连接redis服务，默认是yes,所以默认我们外网是无法访问的，如需外网连接rendis服务则需要将此属性改为no。</td>
</tr>
<tr>
<td>timeout</td>
<td>300</td>
<td>当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能</td>
</tr>
<tr>
<td>loglevel</td>
<td>debug、verbose、notice、warning</td>
<td>日志级别，默认为 notice</td>
</tr>
<tr>
<td>databases</td>
<td>16</td>
<td>设置数据库的数量，默认的数据库是0。整个通过客户端工具可以看得到</td>
</tr>
<tr>
<td>rdbcompression</td>
<td>yes、no</td>
<td>指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大。</td>
</tr>
<tr>
<td>dbfilename</td>
<td>dump.rdb</td>
<td>指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td>dir</td>
<td></td>
<td>指定本地数据库存放目录</td>
</tr>
<tr>
<td>requirepass</td>
<td></td>
<td>设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td>
</tr>
<tr>
<td>maxclients</td>
<td>0</td>
<td>设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息。</td>
</tr>
<tr>
<td>maxmemory</td>
<td>XXX <bytes></td>
<td>指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区。配置项值范围列里XXX为数值。</td>
</tr>
</tbody></table>
<blockquote>
<p>这里我要将daemonize改为yes，不然我每次启动都得在redis-server命令后面加符号&amp;，不这样操作则只要回到Linux控制台则redis服务会自动关闭，同时也将bind注释，将protected-mode设置为no。</p>
<p>这样启动后我就可以在外网访问了。</p>
</blockquote>
<h3 id="查看Redis是否正在运行"><a href="#查看Redis是否正在运行" class="headerlink" title="查看Redis是否正在运行"></a><strong>查看Redis是否正在运行</strong></h3><h4 id="1、采取查看进程方式"><a href="#1、采取查看进程方式" class="headerlink" title="1、采取查看进程方式"></a><strong>1、采取查看进程方式</strong></h4><p><code>ps -aux | grep redis</code></p>
<p>结果如下图：</p>
<p><img src="0-1407665728.png" alt="img"></p>
<h4 id="2、采取端口监听查看方式"><a href="#2、采取端口监听查看方式" class="headerlink" title="2、采取端口监听查看方式"></a><strong>2、采取端口监听查看方式</strong></h4><p><code>netstat -lanp | grep 6379</code></p>
<p>结果如下图：</p>
<p><img src="1-1025164897.png" alt="img"></p>
<h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a><strong>redis-cli</strong></h3><p>redis-cli是连接本地redis服务的一个命令，通过该命令可以连接redis的脚本控制台。如下图</p>
<p><img src="5-1345838995.png" alt="img"></p>
<p>输入exit可以退出redis脚本控制台</p>
<h4 id="关闭运行中的Redis服务"><a href="#关闭运行中的Redis服务" class="headerlink" title="关闭运行中的Redis服务"></a><strong>关闭运行中的Redis服务</strong></h4><p>输入redis-cli 进入控制台后输入命令shutdown即可关闭运行中的Redis服务了。如下图:</p>
<p><img src="8-1051623110.png" alt="img"></p>
<h4 id="远程连接不上问题"><a href="#远程连接不上问题" class="headerlink" title="远程连接不上问题"></a><strong>远程连接不上问题</strong></h4><p>如下图，已经开放了Redis服务的ip不为127.0.0.1,理论上远程客户端应该可以连接了，而且云服务器的端口号也在安全组里开放了。</p>
<p><img src="57-703255053.png" alt="img"></p>
<h2 id="Windows安装redis"><a href="#Windows安装redis" class="headerlink" title="Windows安装redis"></a>Windows安装redis</h2><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3>]]></content>
      <tags>
        <tag>数据库-redis</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo中添加图片</title>
    <url>/2021/02/21/%E5%8D%9A%E5%AE%A2/hexo/hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>在hexo根目录下执行如下命令</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-asset-image</span><br></pre></td></tr></table></figure>


<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>打开在hexo根目录下的 _config.yml 配置文件，找到 post_asset_folder 属性，默认为 false 改为 true</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>此时再执行命令 <code>hexo n test</code> 创建新的文章，</p>
<p>在 <code>source/_posts</code> 中会生成文章 <code>test.md</code> 和同名文件夹 <code>test</code>我们将文章中所使用到的将图片资源均放在 <code>test</code> 中，这时就可以在文章中使用相对路径引用图片资源了<br> <code>[img_name](img_name.jpg)  #文章中的图片资源路径格式</code></p>
<h5 id="创建后再将生成的文件及用来存放图片的文件夹移动到文件夹中，图片依旧可以加载，可以此进行视觉分类"><a href="#创建后再将生成的文件及用来存放图片的文件夹移动到文件夹中，图片依旧可以加载，可以此进行视觉分类" class="headerlink" title="创建后再将生成的文件及用来存放图片的文件夹移动到文件夹中，图片依旧可以加载，可以此进行视觉分类"></a>创建后再将生成的文件及用来存放图片的文件夹移动到文件夹中，图片依旧可以加载，可以此进行视觉分类</h5><h5 id="首次进行图片上传可能会失败，原因未知"><a href="#首次进行图片上传可能会失败，原因未知" class="headerlink" title="首次进行图片上传可能会失败，原因未知"></a>首次进行图片上传可能会失败，原因未知</h5><p><img src="image-20210221172514240.png"></p>
]]></content>
      <tags>
        <tag>博客-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用</title>
    <url>/2021/02/24/%E5%8D%9A%E5%AE%A2/Typora/Typora%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="typora修改简单颜色样式"><a href="#typora修改简单颜色样式" class="headerlink" title="typora修改简单颜色样式"></a>typora修改简单颜色样式</h2><blockquote>
<h4 id="进入-视图-gt-开发者模式"><a href="#进入-视图-gt-开发者模式" class="headerlink" title="进入 视图 &gt; 开发者模式"></a>进入 视图 &gt; 开发者模式</h4></blockquote>
<a id="more"></a>

<p>会显示类似于浏览器的开发者模式窗口</p>
<p><img src="image-20210224100817244.png" alt="image-20210224100817244"></p>
<p>此时选择想要修改样式的内容</p>
<p><img src="image-20210224101056830.png" alt="image-20210224101056830"></p>
<p>修改完毕后右键Copy link address复制文件路径</p>
<p><img src="image-20210224101242695.png" alt="image-20210224101242695"></p>
<blockquote>
<h4 id="查找文件路径"><a href="#查找文件路径" class="headerlink" title="查找文件路径"></a>查找文件路径</h4></blockquote>
<p>  一般文件会有带盘符的完整路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">file:<span class="comment">///E:/6-17/workapp/util/Typora/resources/app//style/window.css</span></span><br></pre></td></tr></table></figure>


<p> 有的文件则以typora:开头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typora: 表示在typora安装目录中，一般为：Typora\resources\app</span></span><br><span class="line"><span class="comment">// userData 可看做style目录</span></span><br><span class="line">typora:<span class="comment">//userData\themes\github.css</span></span><br></pre></td></tr></table></figure>


<p>此时需要</p>
<p><img src="image-20210224103451712.png" alt="image-20210224103451712"></p>
<p>此时直接进入 typora://userData\themes 中</p>
<blockquote>
<h4 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h4></blockquote>
<p>根据行数及选择器名修改样式内容保存即可</p>
]]></content>
      <tags>
        <tag>博客-Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用</title>
    <url>/2021/02/21/%E5%8D%9A%E5%AE%A2/hexo/hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="可以在md文章中添加-lt-more-gt-标签达成折叠文章的目的"><a href="#可以在md文章中添加-lt-more-gt-标签达成折叠文章的目的" class="headerlink" title="可以在md文章中添加&lt;!--more--&gt;标签达成折叠文章的目的"></a>可以在md文章中添加<code>&lt;!--more--&gt;</code>标签达成折叠文章的目的</h3><p>​    标签不能放置在文章开头，否则会被无视</p>
<a id="more"></a>



<h3 id="source-posts中的文件使用文件夹划分并不会达成分级的效果"><a href="#source-posts中的文件使用文件夹划分并不会达成分级的效果" class="headerlink" title="\source_posts中的文件使用文件夹划分并不会达成分级的效果"></a>\source_posts中的文件使用文件夹划分并不会达成分级的效果</h3><p>但可以依靠分包进行视觉上的区分</p>
<h3 id="可以不用添加标号，上传后文章目录会自动添加"><a href="#可以不用添加标号，上传后文章目录会自动添加" class="headerlink" title="可以不用添加标号，上传后文章目录会自动添加"></a>可以不用添加标号，上传后文章目录会自动添加</h3><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><h3 id="md头的作用"><a href="#md头的作用" class="headerlink" title="md头的作用"></a>md头的作用</h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。支援多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分类  创建分类页 hexo new page categories</span></span><br><span class="line">categories: hexo</span><br><span class="line"><span class="comment">// 标签  创建标签页 hexo new page tags</span></span><br><span class="line">type: tags </span><br></pre></td></tr></table></figure>


<h3 id="hexo页面文章使用时间排序，最早的文章会放到最下边，"><a href="#hexo页面文章使用时间排序，最早的文章会放到最下边，" class="headerlink" title="hexo页面文章使用时间排序，最早的文章会放到最下边，"></a>hexo页面文章使用时间排序，最早的文章会放到最下边，</h3><p>所以可以通过修改头部的时间来对文章进行排序</p>
<h3 id="文件名并没有用，页面中最大的标题为文件头中title后的内容"><a href="#文件名并没有用，页面中最大的标题为文件头中title后的内容" class="headerlink" title="文件名并没有用，页面中最大的标题为文件头中title后的内容"></a>文件名并没有用，页面中最大的标题为文件头中title后的内容</h3><h3 id="将Hexo设置成中文"><a href="#将Hexo设置成中文" class="headerlink" title="将Hexo设置成中文"></a>将Hexo设置成中文</h3><p>很多文档和博客都将language设置成zh-Hans，结果登录个人站一直不能显示中文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: Welcome</span><br><span class="line">description: you can enjoy a grander sight，if you climb to a greater height</span><br><span class="line">keywords:</span><br><span class="line">author: RedeeMi</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: </span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<p>找到next文件夹下的languages文件夹，看到zh-CN.yml，所以选择把languages设为zh-CN<br><img src="https://img-blog.csdnimg.cn/20201216200852675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyMzE2OTEx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: RedeeMi的个人站</span><br><span class="line">subtitle: Welcome</span><br><span class="line">description: you can enjoy a grander sight，if you climb to a greater height</span><br><span class="line">keywords:</span><br><span class="line">author: RedeeMi</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: </span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<p>如果还没有显示为中文，clean后再登录即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>


<h2 id="Hexo-next主题添加"><a href="#Hexo-next主题添加" class="headerlink" title="Hexo next主题添加"></a>Hexo next主题添加</h2><h3 id="Hexo-next主题添加访问统计"><a href="#Hexo-next主题添加访问统计" class="headerlink" title="Hexo next主题添加访问统计"></a>Hexo next主题添加访问统计</h3><h5 id="注：不同主题添加统计的方式不同"><a href="#注：不同主题添加统计的方式不同" class="headerlink" title="注：不同主题添加统计的方式不同"></a>注：不同主题添加统计的方式不同</h5><h4 id="1-打开next主题配置文件-themes-next-config-yml，搜索找到busuanzi-count，把enable设置为true"><a href="#1-打开next主题配置文件-themes-next-config-yml，搜索找到busuanzi-count，把enable设置为true" class="headerlink" title="1. 打开next主题配置文件\themes\next\_config.yml，搜索找到busuanzi_count，把enable设置为true"></a>1. 打开next主题配置文件\themes\next\_config.yml，搜索找到<strong>busuanzi_count</strong>，把enable设置为true</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.#展示访问数</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  total_visitors: true   #统计访客数</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true    #统计访问数</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true   #统计文章阅读数</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>


<h4 id="2-同样是在next主题配置文件-themes-next-config-yml下，搜索footer，在它底下添加counter，设值为true"><a href="#2-同样是在next主题配置文件-themes-next-config-yml下，搜索footer，在它底下添加counter，设值为true" class="headerlink" title="2. 同样是在next主题配置文件\themes\next\_config.yml下，搜索footer，在它底下添加counter，设值为true"></a>2. 同样是在next主题配置文件\themes\next\_config.yml下，搜索<strong>footer</strong>，在它底下添加counter，设值为true</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 统计  </span><br><span class="line">counter: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>


<h4 id="3-来到themes-next-layout-partials，找到footer-swig文件，打开编辑，在底下添加代码"><a href="#3-来到themes-next-layout-partials，找到footer-swig文件，打开编辑，在底下添加代码" class="headerlink" title="3. 来到themes\next\layout\_partials，找到footer.swig文件，打开编辑，在底下添加代码"></a>3. 来到themes\next\layout\_partials，找到<strong>footer.swig</strong>文件，打开编辑，在底下添加代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.footer.counter %&#125;</span><br><span class="line">    &lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Hexo-next主题添加搜索"><a href="#Hexo-next主题添加搜索" class="headerlink" title="Hexo next主题添加搜索"></a>Hexo next主题添加搜索</h3><h4 id="1-安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令："><a href="#1-安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：" class="headerlink" title="1. 安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令："></a>1. 安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>


<h4 id="2-全局配置文件-config-yml，新增如下内容："><a href="#2-全局配置文件-config-yml，新增如下内容：" class="headerlink" title="2.全局配置文件_config.yml，新增如下内容："></a>2.全局配置文件_config.yml，新增如下内容：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 添加搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure>


<h4 id="3-hexo主题配置文件（-themes-next-config-yml），修改local-search的enable为true："><a href="#3-hexo主题配置文件（-themes-next-config-yml），修改local-search的enable为true：" class="headerlink" title="3.hexo主题配置文件（\themes\next\_config.yml），修改local_search的enable为true："></a>3.hexo主题配置文件（\themes\next\_config.yml），修改local_search的enable为true：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h3 id="Hexo-NexT主题下开启其他菜单项，比如分类、标签、关于"><a href="#Hexo-NexT主题下开启其他菜单项，比如分类、标签、关于" class="headerlink" title="Hexo NexT主题下开启其他菜单项，比如分类、标签、关于"></a>Hexo NexT主题下开启其他菜单项，比如分类、标签、关于</h3><p>首先打开主题下的配置文件_config.yml，然后搜索menu找到如下配置项，将about、tags、categories前的#号去掉，就开启了关于、标签和分类标签，当然还有其他菜单项也可以开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Menu Settings</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> When running the site <span class="keyword">in</span> a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Usage: `Key: /link/ || icon`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Key is the name of menu item. If the translation <span class="keyword">for</span> this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Value before `||` delimiter is the target link.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Value after `||` delimiter is the name of FontAwesome icon. If icon (with or without delimiter) is not specified, question icon will be loaded.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> External url should start with http:// or https://</span></span><br><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line"><span class="meta">  #</span><span class="bash">schedule: /schedule/ || calendar</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<p>重新生成部署后，可以看到新增的菜单项，但是单击后会报如下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cannot GET /about/</span><br><span class="line">Cannot GET /tags/</span><br><span class="line">Cannot GET /categories/</span><br></pre></td></tr></table></figure>

<p>这是因为你还需运行如下命令新建相关页面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>


<p>运行结果如下，会再source文件下创建about、tags、categories文件夹，每个文件夹下还会创建一个index.md文件表示关于、标签页分类页面，编辑这三个MarkDown文件可以自定义这三个页面的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\hexo\blog&gt;hexo new page &quot;about&quot;</span><br><span class="line">INFO  Created: D:\hexo\blog\source\about\index.md</span><br><span class="line"></span><br><span class="line">D:\hexo\blog&gt;hexo new page &quot;tags&quot;</span><br><span class="line">INFO  Created: D:\hexo\blog\source\tags\index.md</span><br><span class="line"></span><br><span class="line">D:\hexo\blog&gt;hexo new page &quot;categories&quot;</span><br><span class="line">INFO  Created: D:\hexo\blog\source\categories\index.md</span><br></pre></td></tr></table></figure>


<p>还差最后一步，打开各页面对应的index.md文件，编辑如下内容，title和date是默认生成的，增加type即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">title: about</span><br><span class="line">date: 2019-06-25 19:16:17</span><br><span class="line"></span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">title: about</span><br><span class="line">date: 2019-06-25 19:16:17</span><br><span class="line"></span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">title: about</span><br><span class="line">date: 2019-06-25 19:16:17</span><br><span class="line"></span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Hexo-分类文章进行分级"><a href="#Hexo-分类文章进行分级" class="headerlink" title="Hexo 分类文章进行分级"></a>Hexo 分类文章进行分级</h3><p>添加分类页面成功后</p>
<p>文章添加<code>categories: 分类1</code>即可添加分类</p>
<p>添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">categories: </span><br><span class="line">- 笔记</span><br><span class="line">- javascript</span><br><span class="line">- 面向对象编程</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">category: </span><br><span class="line">- 笔记</span><br><span class="line">- javascript</span><br><span class="line">- 面向对象编程</span><br></pre></td></tr></table></figure>
<p>即可进行分类分级</p>
]]></content>
      <tags>
        <tag>博客-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo指令</title>
    <url>/2021/02/21/%E5%8D%9A%E5%AE%A2/hexo/hexo%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>​    </p>
<h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><p>​    hexo new “文章名称”</p>
<a id="more"></a>

<p>​    或</p>
<p>​    hexo n “文章名称”</p>
<h3 id="清理页面"><a href="#清理页面" class="headerlink" title="清理页面"></a>清理页面</h3><p>hexo clean</p>
<h3 id="生成页面-generate"><a href="#生成页面-generate" class="headerlink" title="生成页面 (generate)"></a>生成页面 (generate)</h3><p>​    hexo g </p>
<h3 id="本地预览页面（show）"><a href="#本地预览页面（show）" class="headerlink" title="本地预览页面（show）"></a>本地预览页面（show）</h3><p>​    hexo s </p>
<h3 id="部署发布-deploy"><a href="#部署发布-deploy" class="headerlink" title="部署发布 (deploy)"></a>部署发布 (deploy)</h3><p>​    hexo d</p>
<h3 id="生成标签页面-页面文章头部需要添加-type-tags"><a href="#生成标签页面-页面文章头部需要添加-type-tags" class="headerlink" title="生成标签页面  页面文章头部需要添加  type: tags"></a>生成标签页面  页面文章头部需要添加  type: tags</h3><h3 id="文章通过添加（tags-标签）来添加标签"><a href="#文章通过添加（tags-标签）来添加标签" class="headerlink" title="文章通过添加（tags: 标签）来添加标签"></a>文章通过添加（tags: 标签）来添加标签</h3><p>​    hexo new page 标签</p>
<h3 id="生成分类页面-头部需要添加-type-categoriese"><a href="#生成分类页面-头部需要添加-type-categoriese" class="headerlink" title="生成分类页面  头部需要添加  type: categoriese"></a>生成分类页面  头部需要添加  type: categoriese</h3><h3 id="文章通过添加（categoriese-分类）来添加分类"><a href="#文章通过添加（categoriese-分类）来添加分类" class="headerlink" title="文章通过添加（categoriese: 分类）来添加分类"></a>文章通过添加（categoriese: 分类）来添加分类</h3><p>​    hexo new page 分类</p>
]]></content>
      <tags>
        <tag>博客-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo添加分类及标签</title>
    <url>/2021/02/21/%E5%8D%9A%E5%AE%A2/hexo/hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="Hexo-添加分类及标签"><a href="#Hexo-添加分类及标签" class="headerlink" title="Hexo 添加分类及标签"></a>Hexo 添加分类及标签</h1><p>生成的新文件夹都在source下也就是和放文章的文件夹一块 以下所有命令都是在博客文件目录下执行</p>
<a id="more"></a>

<h4 id="1-创建“分类”选项"><a href="#1-创建“分类”选项" class="headerlink" title="1. 创建“分类”选项"></a>1. 创建“分类”选项</h4><p>生成“分类”页并添加tpye属性,进入博客目录。执行下方命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-04-22 14:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加type: “categories”到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-04-24 15:30:30</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<p>给文章添加“categories”属性</p>
<p>打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
<h4 id="2-创建“标签”选项"><a href="#2-创建“标签”选项" class="headerlink" title="2. 创建“标签”选项"></a>2. 创建“标签”选项</h4><p>生成“标签”页并添加tpye属性，<code>页面进入标签页默认找tags目录</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-04-22 14:22:08</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-04-24 15:40:24</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<p>给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2019-04-24 15:40:24</span><br><span class="line">categories: - Hexo</span><br><span class="line">tags: - 博客</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用</title>
    <url>/2021/02/23/%E7%8B%82%E7%A5%9E%E8%AF%B4/git/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="git项目搭建"><a href="#git项目搭建" class="headerlink" title="git项目搭建"></a>git项目搭建</h2><h3 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h3><a id="more"></a>

<p><img src="image-liucheng.png"></p>
<h3 id="本地搭建仓库"><a href="#本地搭建仓库" class="headerlink" title="本地搭建仓库"></a>本地搭建仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>提示初始化一个空的git库在<code>G:/test/test/.git/</code></p>
<p><img src="image-20210224090517320.png" alt="image-20210224090517320"></p>
<p>此时运行命令的位置会有</p>
<p><img src="image-20210224090651065.png" alt="image-20210224090651065"></p>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 克隆整个项目及其整个代码历史(版本信息)</span><br><span class="line"># https:<span class="operator">/</span><span class="operator">/</span>gitee.com<span class="operator">/</span>kuangstudy<span class="operator">/</span>openclass.git</span><br><span class="line">git clone [url]</span><br></pre></td></tr></table></figure>


<h2 id="git文件操作"><a href="#git文件操作" class="headerlink" title="git文件操作"></a>git文件操作</h2><blockquote>
<h3 id="文件4种状态"><a href="#文件4种状态" class="headerlink" title="文件4种状态"></a>文件4种状态</h3></blockquote>
<ul>
<li><strong>Untracked</strong>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为<code>Staged</code></li>
<li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为<code>Modified</code>. 如果使用<code>git rm</code>移出版本库, 则成为<code>Untracked</code>文件</li>
<li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过<code>git add</code>可进入暂存<code>staged</code>状态, 使用<code>git checkout</code> 则丢弃修改过, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改</li>
<li><strong>Staged</strong>: 暂存状态. 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code></li>
</ul>
<blockquote>
<h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line"># 提交所有文件到暂存区  </span><br><span class="line">git add . </span><br><span class="line">    </span><br><span class="line"># 提交暂存区的内容到本地仓库</span><br><span class="line">git commit -m <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h4 id="使用该命令查看本地新搭建的项目时，显示内容为："><a href="#使用该命令查看本地新搭建的项目时，显示内容为：" class="headerlink" title="使用该命令查看本地新搭建的项目时，显示内容为："></a>使用该命令查看本地新搭建的项目时，显示内容为：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前在master分支</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前未进行提交</span></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前无任何内容需要提交</span></span><br><span class="line"><span class="function">nothing to <span class="title">commit</span> <span class="params">(create/copy files and use <span class="string">&quot;git add&quot;</span> to track)</span></span></span><br></pre></td></tr></table></figure>
<p>​    </p>
<h4 id="新建文件hello-txt-再使用该命令查看，显示内容为："><a href="#新建文件hello-txt-再使用该命令查看，显示内容为：" class="headerlink" title="新建文件hello.txt 再使用该命令查看，显示内容为："></a>新建文件hello.txt 再使用该命令查看，显示内容为：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示未跟踪的文件</span></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未添加任何提交但是目前有未跟踪的文件</span></span><br><span class="line"><span class="function">nothing added to commit but untracked files <span class="title">present</span> <span class="params">(use <span class="string">&quot;git add&quot;</span> to track)</span></span></span><br></pre></td></tr></table></figure>


<h4 id="git-add-（提交所有文件到暂存区）"><a href="#git-add-（提交所有文件到暂存区）" class="headerlink" title="git add . （提交所有文件到暂存区）"></a>git add . （提交所有文件到暂存区）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要提交的更改</span></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">		<span class="comment">// 提示有新文件  hello.txt</span></span><br><span class="line">        <span class="keyword">new</span> file:   hello.txt</span><br></pre></td></tr></table></figure>


<h4 id="git-commit-m-（提交暂存区的内容到本地仓库）"><a href="#git-commit-m-（提交暂存区的内容到本地仓库）" class="headerlink" title="git commit -m （提交暂存区的内容到本地仓库）"></a>git commit -m （提交暂存区的内容到本地仓库）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有东西需要提交，工作树是干净的</span></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>


<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中,比如数据库文件,临时文件,设计文件等<br>在主目录下建立”.gitignore”文件,此文件有如下规则: </p>
<ol>
<li>忽略文件中的空行或以井号( # )开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如:星号(* )代表任意多个字符,问号( ? )代表-个字符,方括号( [abc] )代表可选字符范围,<br>大括号( string1，string2，…. )代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号(!) , 表示例外规则,将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符 (/) ,表示要忽略的文件在此目录下,而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符(1) , 表示要忽略的是此目录下该名称的子目录,而非文件(默认文件或目录都忽略)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt		#忽略所有. txt结尾的文件</span><br><span class="line">!lib.txt	#但lib.txt除外</span><br><span class="line">/temp 		#仅忽路项目根目录下的TODO文件,不包括其它目录temp</span><br><span class="line">build/		#忽略bui1d/目录下的所有文件</span><br><span class="line">doc<span class="comment">/*.txt	#忽略 doc/notes.txt 但不包括doc/server/arch.txt</span></span><br></pre></td></tr></table></figure>


<h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><blockquote>
<h3 id="github-是有墙的，比较慢，在国内的话一般使用-gitee-，公司中有时候会搭建自己的-gitlib-服务器"><a href="#github-是有墙的，比较慢，在国内的话一般使用-gitee-，公司中有时候会搭建自己的-gitlib-服务器" class="headerlink" title="==github==是有墙的，比较慢，在国内的话一般使用==gitee==，公司中有时候会搭建自己的==gitlib==服务器"></a>==github==是有墙的，比较慢，在国内的话一般使用==gitee==，公司中有时候会搭建自己的==gitlib==服务器</h3></blockquote>
<p>设置本机绑定SSH公钥，实现免密登录</p>
<ol>
<li>位于<code>C:\Users\Administrator\.ssh</code>目录下</li>
</ol>
<p><img src="image-20210226143025211.png" alt="image-20210226143025211"></p>
<ol start="2">
<li>生成公钥</li>
</ol>
<p>ssh-keygen -t rsa</p>
<ol start="3">
<li>生成后产生两个文件，<code>以pub结尾的为公钥，另外一个为私钥</code></li>
</ol>
<p><img src="image-20210226143143961.png" alt="image-20210226143143961"></p>
<ol start="4">
<li>将公钥粘如码云 设置 -&gt; 安全设置 -&gt; SSH公钥</li>
</ol>
<h2 id="idea集成git"><a href="#idea集成git" class="headerlink" title="idea集成git"></a>idea集成git</h2><blockquote>
<h3 id="新项目中集成git"><a href="#新项目中集成git" class="headerlink" title="新项目中集成git"></a>新项目中集成git</h3></blockquote>
<ol>
<li><p>在码云中创建项目并拉到本地</p>
</li>
<li><p>新建项目</p>
</li>
<li><p>将码云中拉取得项目的内容全部复制到新建的项目中</p>
<p><img src="image-20210226165218143.png" alt="image-20210226165218143"></p>
</li>
</ol>
<blockquote>
<h3 id="提交代码到远程"><a href="#提交代码到远程" class="headerlink" title="提交代码到远程"></a>提交代码到远程</h3></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;修改&quot;</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交到远程  </span></span><br><span class="line"><span class="comment">// 提交到指定分支： git push origin master</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>


<h2 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h2><p>多个分支并行执行(不重合)，代码就不冲突，也就是同时存在多个版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line">    </span><br><span class="line"># 新建分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line">    </span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">git merge [branch]</span><br><span class="line">    </span><br><span class="line"># 删除分支</span><br><span class="line">git branch -d [branch]</span><br><span class="line">    </span><br><span class="line"># 删除远程分支</span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>


<p>==master主分支应该非常稳定,用来发布新版本, 一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作,工作完后,比如: 要发布,或者说dev分支代码稳定后可以合并到主分支master上来。==</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用问题</title>
    <url>/2021/03/05/%E7%8B%82%E7%A5%9E%E8%AF%B4/git/git%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="提交过大文件到线上仓库，删除该文件无法提交的问题"><a href="#提交过大文件到线上仓库，删除该文件无法提交的问题" class="headerlink" title="提交过大文件到线上仓库，删除该文件无法提交的问题"></a>提交过大文件到线上仓库，删除该文件无法提交的问题</h2><blockquote>
<p>报错提示</p>
</blockquote>
<p>remote: error: File: 68c625d7c4c72d644859123e74957a00701ca947 128.78 MB, exceeds 100.00 MB.<br>remote: Use command below to see the filename:<br>remote: git rev-list –objects –all | grep 68c625d7c4c72d644859123e74957a00701ca947<br>remote: Please remove the file from history and try again.</p>
<blockquote>
<p>解决方法</p>
</blockquote>
<ol>
<li>使用<code>git clone uri</code>重新拉取一份项目    </li>
<li>使用新项目中的<code>.git</code>替换报错项目中的<code>.git</code>文件夹，存在<code>.gitee</code>文件夹时也一并替换</li>
<li>重新执行提交代码命令即可</li>
</ol>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git安装及配置</title>
    <url>/2021/02/22/%E7%8B%82%E7%A5%9E%E8%AF%B4/git/git%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="淘宝镜像安装地址"><a href="#淘宝镜像安装地址" class="headerlink" title="淘宝镜像安装地址"></a>淘宝镜像安装地址</h3><p><a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></p>
<a id="more"></a>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>需要先清理环境变量，再删除文件</p>
<h3 id="查看git配置"><a href="#查看git配置" class="headerlink" title="查看git配置"></a>查看git配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于git所有的配置</span></span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统配置</span></span><br><span class="line">git config --system --list</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 用户自身的配置   其中用户名和邮箱是必须配置的</span></span><br><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>


<h4 id="所有的配置文件，其实都保存在本地"><a href="#所有的配置文件，其实都保存在本地" class="headerlink" title="所有的配置文件，其实都保存在本地"></a><code>所有的配置文件，其实都保存在本地</code></h4><h4 id="设置用户名和邮箱-用户标识，必要"><a href="#设置用户名和邮箱-用户标识，必要" class="headerlink" title="设置用户名和邮箱(用户标识，必要)"></a>设置用户名和邮箱(用户标识，必要)</h4><h5 id="本地git配置文件位置"><a href="#本地git配置文件位置" class="headerlink" title="本地git配置文件位置"></a>本地git配置文件位置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --system 系统级 旧版位置   </span></span><br><span class="line"><span class="comment">// 新版为位于 Git\mingw64\etc\gitconfig</span></span><br><span class="line">Git\mingw64\etc\gitconfig</span><br><span class="line">    </span><br><span class="line"><span class="comment">// --global 用户配置</span></span><br><span class="line">C:\Users\Administrator\.gitconfig</span><br></pre></td></tr></table></figure>


<h5 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置用户名</span></span><br><span class="line">git config --global user.name <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">// 配置邮箱</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&quot;</span>    </span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git概念</title>
    <url>/2021/02/22/%E7%8B%82%E7%A5%9E%E8%AF%B4/git/git%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>什么是版本控制、版本迭代、版本管理器</p>
<a id="more"></a>

<p>​        <code>版本控制</code>( Revision control )是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录,备份以便恢复以前的版本的软件工程技术。<br>​    ●  实现跨区域多人协同开发<br>​    ●  追踪和记载一个或者多个文件的历史记录<br>​    ●  组织和保护你的源代码和文档<br>​    ●  统计工作量<br>​    ●  并行开发、提高开发效率<br>​    ●  跟踪记录整个软件的开发过程<br>​    ●  减轻开发人员的负担,节省时间,同时降低人为错误<br>简单说就是用于管理多人协同开发项目的技术。</p>
<h4 id="手动控制版"><a href="#手动控制版" class="headerlink" title="手动控制版"></a>手动控制版</h4><p><img src="image-20210222092842985.png"></p>
<h3 id="版本控制-1"><a href="#版本控制-1" class="headerlink" title="版本控制"></a>版本控制</h3><p>版本控制包括：检入检出控制、分支和合并、历史记录。</p>
<p>1．检入检出控制<br>        软件开发人员对源文件的修改不能在软件配置管理库中进行，对源文件的修改依赖于基本的文件系统并在各自的工作空间下进行。为了方便软件开发，需要不同的软件开发人员组织各自的工作空间。一般说来，不同的工作空间由不同的目录表示，而对工作空间的访问，由文件系统提供的文件访问权限加以控制。访问控制需要管理各个人员存取或修改一个特定软件配置对象的权限。开发人员能够从库中取出对应项目的配置项进行修改，并检入到软件配置库中，对版本进行“升级”；配置管理人员可以确定多余配置项并删除。同步控制的实质是版本的检入检出控制。检入就是把软件配置项从用户的工作环境存入到软件配置库的过程，检出就是把软件配置项从软件配置库中取出的过程。检人是检出的逆过程。同步控制可用来确保由不同的人并发执行的修改不会产生混乱。</p>
<p>2．分支和合并<br>        版本分支(以一个已有分支的特定版本为起点，但是独立发展的版本序列)的人工方法就是从主版本——称为主干上拷贝一份，并做上标记。在实行了版本控制后，版本的分支也是一份拷贝，这时的拷贝过程和标记动作由版本控制系统完成。版本合并(来自不同分支的两个版本合并为其中一个分支的新版本)有两种途径，一是将版本A的内容附加到版本B中；另一种是合并版本A和版本B的内容，形成新的版本C。</p>
<p>3．历史记录<br>        版本的历史记录有助于对软件配置项进行审核，有助于追踪问题的来源。历史记录包括版本号、版本修改时间、版本修改者、版本修改描述等最基本的内容，还可以有其他一些辅助性内容，比如版本的文件大小和读写属性。</p>
<h3 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h3><p>​    ●  Git<br>​    ●  SVN ( Subversion )<br>​    ●  CVS ( Concurrent Versions System )<br>​    ●  VSS ( Micorosoft Visual SourceSafe )<br>​    ●  TFS ( Team Foundation Server )<br>​    ●  Visual Studio Online</p>
<h3 id="GIT与SVN的区别"><a href="#GIT与SVN的区别" class="headerlink" title="GIT与SVN的区别"></a>GIT与SVN的区别</h3><h4 id="本地版本控制-如RCS"><a href="#本地版本控制-如RCS" class="headerlink" title="本地版本控制(如RCS)"></a>本地版本控制(如RCS)</h4><p>​        记录每次更新，对每个版本做一个快照，如将每次更新做备份然后按日期排版仅适用于个人</p>
<p><img src="image-20210222093134728.png"></p>
<h4 id="集中版本控制-如-SVN"><a href="#集中版本控制-如-SVN" class="headerlink" title="集中版本控制(如 SVN)"></a>集中版本控制(如 SVN)</h4><p>​        所有的版本数据都保存在服务器上,协同开发者从服务器上同步更新或上传自己的修改所有的开发者都与该服务器做交互，若该服务器出现问题，则将无法上传及获取代码，一般解决方法为定期备份代码</p>
<p><img src="image-20210222093238406.png"></p>
<h4 id="分布式版本控制-如git"><a href="#分布式版本控制-如git" class="headerlink" title="分布式版本控制(如git)"></a>分布式版本控制(如git)</h4><p><img src="image-20210222093319633.png"></p>
<h3 id="git基本理论-核心"><a href="#git基本理论-核心" class="headerlink" title="git基本理论(核心)"></a>git基本理论(核心)</h3><h4 id="分支内容存储在HEAD中"><a href="#分支内容存储在HEAD中" class="headerlink" title="分支内容存储在HEAD中"></a>分支内容存储在HEAD中</h4><p><img src="image-20210223180806311.png" alt="image-20210223180806311"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>


<h4 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h4><p>​        git本地有三个工作区域，<code>工作目录(Working Directory)</code>、<code>暂存区(Stage Index)</code>、<code>资源库(Repository或Git Directory)</code>。如果在加上<code>远程的git仓库(Rermote Directory)</code>就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<p><img src="%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p>
<ul>
<li><p>Working Directory：工作区，就是平时存放项目代码的地方</p>
</li>
<li><p>Index / Stage ：暂存区,用于临时存放你的改动，事实上它只是一个文件,保存即将提交到文件列表信息</p>
</li>
<li><p>Repository: 仓库区(或本地仓库),就是安全存放数据的位置 ,这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p>
</li>
<li><p>Remote : 远程仓库（github或gitee码云）,托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p>
</li>
</ul>
<p>其中开发者仅需管理Working Directory和Remote，暂存区和仓库区使用命令操作即可</p>
<p>下图可理解为git管理的项目的示意图:</p>
<p>​    Directory：整个项目</p>
<p>​        WorkSpace：代码文件</p>
<p>​        .git(隐藏文件夹)：其中包括Index暂存区及Head目录</p>
<p><img src="image-20210223181645558.png" alt="image-20210223181645558"></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装</title>
    <url>/2021/03/02/%E7%8B%82%E7%A5%9E%E8%AF%B4/Docker/Docker%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h2><a id="more"></a>

<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=793314303,480081697&fm=26&gp=0.jpg" alt="img"></p>
<p><strong>镜像（image）：</strong></p>
<p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像 ==&gt; run ==&gt; tomcat1容器（提供服务器），通过这个镜像可以创建多个容器（最终服务或者项目运行就是在容器中的）</p>
<p><strong>容器（container）：</strong></p>
<p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的。</p>
<p>可以将容器理解为一个简易的Linux系统</p>
<p>基本命令：启动、停止、删除</p>
<p><strong>仓库（repository）：</strong></p>
<p>仓库就是存放镜像的地方</p>
<p>仓库分为共有仓库和私有仓库</p>
<p>Docker Hub (默认)</p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote>
<h3 id="卸载旧的版本"><a href="#卸载旧的版本" class="headerlink" title="卸载旧的版本"></a>卸载旧的版本</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">            docker-client \</span><br><span class="line">            docker-client-latest \</span><br><span class="line">            docker-common \</span><br><span class="line">            docker-latest \</span><br><span class="line">            docker-latest-logrotate \</span><br><span class="line">            docker-logrotate \</span><br><span class="line">            docker-engine</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="需要的安装包"><a href="#需要的安装包" class="headerlink" title="需要的安装包"></a>需要的安装包</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="设置镜像的仓库"><a href="#设置镜像的仓库" class="headerlink" title="设置镜像的仓库"></a>设置镜像的仓库</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo   # 国外镜像仓库</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 阿里镜像仓库</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">	https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>


<blockquote>
<p>更新yum软件包索引</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line">// centos8可能需要使用</span><br><span class="line">yum makecache timer</span><br></pre></td></tr></table></figure>




<blockquote>
<h3 id="安装docker相关的内容"><a href="#安装docker相关的内容" class="headerlink" title="安装docker相关的内容"></a>安装docker相关的内容</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker-ce 社区版本  ee企业版</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>


<blockquote>
<p>安装报错</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: </span><br><span class="line"> Problem: problem with installed package buildah-1.15.1-2.module_el8.3.0+475+c50ce30b.x86_64</span><br><span class="line"></span><br><span class="line">  - package buildah-1.15.1-2.module_el8.3.0+475+c50ce30b.x86_64 requires runc &gt;= 1.0.0-26, but none of the providers can be installed</span><br><span class="line">  - package buildah-1.16.7-4.module_el8.3.0+699+d61d9c41.x86_64 requires runc &gt;= 1.0.0-26, but none of the providers can be installed</span><br><span class="line">  - package containerd.io-1.4.3-3.1.el8.x86_64 conflicts with runc provided by runc-1.0.0-68.rc92.module_el8.3.0+475+c50ce30b.x86_64</span><br><span class="line">  - package containerd.io-1.4.3-3.1.el8.x86_64 obsoletes runc provided by runc-1.0.0-68.rc92.module_el8.3.0+475+c50ce30b.x86_64</span><br><span class="line">  - package containerd.io-1.4.3-3.1.el8.x86_64 conflicts with runc provided by runc-1.0.0-70.rc92.module_el8.3.0+699+d61d9c41.x86_64</span><br><span class="line">  - package containerd.io-1.4.3-3.1.el8.x86_64 obsoletes runc provided by runc-1.0.0-70.rc92.module_el8.3.0+699+d61d9c41.x86_64</span><br><span class="line">  - cannot install the best candidate for the job</span><br><span class="line">  - package runc-1.0.0-56.rc5.dev.git2abd837.module_el8.3.0+569+1bada2e4.x86_64 is filtered out by modular filtering</span><br><span class="line">  - package runc-1.0.0-64.rc10.module_el8.3.0+479+69e2ae26.x86_64 is filtered out by modular filtering</span><br><span class="line">    (try to add &#x27;--allowerasing&#x27; to command line to replace conflicting packages or &#x27;--skip-broken&#x27; to skip uninstallable packages or &#x27;--nobest&#x27; to use not only best candidate packages)</span><br></pre></td></tr></table></figure>


<p>解决方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看是否安装podman</span></span><br><span class="line">rpm -q podman</span><br><span class="line">podman-1.4.2-5.module_el8.1.0+237+63e26edc.x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除Podman</span></span><br><span class="line">dnf remove podman</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 未解决时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入下面的命令继续安装：</span></span><br><span class="line">yum install --allowerasing docker-ce</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看docker是否启动成功(查看版本信息)</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p><img src="image-20210304190851060.png" alt="image-20210304190851060"></p>
<blockquote>
<h3 id="运行hello-world"><a href="#运行hello-world" class="headerlink" title="运行hello-world"></a>运行hello-world</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker run hello-world</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 提示未寻找到hello-world镜像</span></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 执行pull远程拉取官方library/hello-world镜像</span></span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示拉取成功</span></span><br><span class="line">0e03bdcc26d7: Pull complete </span><br><span class="line">Digest: sha256:7e02330c713f93b1d3e4c5003350d0dbe215ca269dd1d84a4abc577908344b30</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行hello-world表示docker安装成功</span></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="查看下载的hello-world镜像在不在"><a href="#查看下载的hello-world镜像在不在" class="headerlink" title="查看下载的hello-world镜像在不在"></a>查看下载的hello-world镜像在不在</h3></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   14 months ago   13.3kB</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h3><p>docker默认工作路径： /var/lib/docker</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载docker</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件目录</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line">rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>








]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker概念</title>
    <url>/2021/03/02/%E7%8B%82%E7%A5%9E%E8%AF%B4/Docker/Docker%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h2><a id="more"></a>

<p>入门</p>
<ul>
<li><p>Docker概述</p>
</li>
<li><p>Docker安装</p>
</li>
<li><p>Docker命令</p>
<ul>
<li>镜像</li>
<li>容器</li>
<li>操作</li>
<li>……</li>
</ul>
</li>
<li><p>==Docker镜像==</p>
</li>
<li><p>==容器数据卷==</p>
</li>
</ul>
<p>构建镜像</p>
<ul>
<li>DockerFile</li>
</ul>
<p>基于网络</p>
<ul>
<li>Docker网络原理</li>
<li>IDEA整合Docker</li>
</ul>
<p>集群</p>
<ul>
<li>Docker Compose</li>
<li>Docker Swarm</li>
</ul>
<p>持续编程持续部署</p>
<ul>
<li>CI/CD Jenkins</li>
</ul>
<h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><blockquote>
<h3 id="Docker为什么出现"><a href="#Docker为什么出现" class="headerlink" title="Docker为什么出现"></a>Docker为什么出现</h3></blockquote>
<ol>
<li>一款产品：开发 – 上线，应用环境，应用配置</li>
<li>开发 – 运维。问题：我在我的电脑上可以运行！版本更新，导致服务不可用！对于运维来说，考验就十分大</li>
<li>环境配置十分麻烦，每台机器都要部署环境(集群Redis、ES、Hadoop……)，费时费力</li>
</ol>
<p>​    发布项目时，将项目带着环境一起发布(jar + (Redis + Mysql + jdk + ES))，项目带上环境安装打包！</p>
<p>​    </p>
<p>​    java —- apk —- 发布（应用商店） —- 客户使用apk —- 安装即可使用</p>
<p>​    java开发 —- jar + 环境 —- 打包项目带上环境 —- Docker仓库（类似于商店）—- 客户可直接下载发布的镜像 —- 直接运行即可</p>
<p>​    Docker的思想来自于集装箱</p>
<p>​    <img src="image-20210302155750048.png" alt="image-20210302155750048"></p>
<p>​    </p>
<p>​    多个应用使用的都是同一套环境可能存在端口冲突等问题</p>
<p>​    ==隔离==：Docker核心思想，打包装箱，每个箱子都是互相隔离的，即每个应用使用各自的环境</p>
<h2 id="Docker资源"><a href="#Docker资源" class="headerlink" title="Docker资源"></a>Docker资源</h2><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p><img src="image-20210302163351910.png" alt="image-20210302163351910"></p>
<p>官方文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p>
<p>Docker hub(类似于github的仓库)：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h2 id="Docker作用"><a href="#Docker作用" class="headerlink" title="Docker作用"></a>Docker作用</h2><blockquote>
<p>在容器技术出现前，都是使用的虚拟机技术，虚拟机和Docker的容器技术都是==虚拟化技术==</p>
</blockquote>
<p>虚拟机技术：在windows中装一个VMware，通过这个软件虚拟出来一台或多台电脑(特点：笨重，与真实的电脑是一样的)</p>
<p>容器技术：隔离，镜像，十分小巧，仅需运行镜像即可</p>
<blockquote>
<p>虚拟机技术</p>
</blockquote>
<p><img src="image-20210302172210980.png" alt="image-20210302172210980"></p>
<p>在windows中装一个VMware，通过这个软件虚拟出来一台或多台电脑(特点：笨重，与真实的电脑是一样的)</p>
<p>虚拟机技术缺点：</p>
<ol>
<li>资源占用十分多</li>
<li>冗余步骤多</li>
<li>启动慢</li>
</ol>
<blockquote>
<p>容器化技术</p>
</blockquote>
<p>==容器化技术不是模拟一个完整的操作系统==</p>
<p> <img src="image-20210302172812341.png" alt="image-20210302172812341">    </p>
<p>与虚拟机技术比较：</p>
<ul>
<li>传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在宿主机的内核中，容器是没有自己的内核的，也没有虚拟硬件，所以就轻便了</li>
<li>每个容器之间互相隔离，每个容器内都有一个属于自己的文件系统，互不影响。</li>
</ul>
<blockquote>
<p>DevOps（开发、运维）</p>
</blockquote>
<p><strong>应用更快速的交付和部署</strong></p>
<p>传统：一堆帮助文档，安装程序</p>
<p>Docker：打包镜像发布测试，一键运行</p>
<p><strong>更便捷的升级和扩缩容</strong></p>
<p>项目打包成一个镜像后，若需要从服务器A 扩展到 服务器B，仅需要在服务器B上运行镜像文件即可</p>
<p><strong>更简单的系统运维</strong></p>
<p>在容器化之后，开发与测试环境都是高度一致的</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例，服务器性能可以被压榨极致。</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2021/03/02/%E7%B3%BB%E7%BB%9F/Linux/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><a id="more"></a>

<blockquote>
<h3 id="系统信息查看"><a href="#系统信息查看" class="headerlink" title="系统信息查看"></a>系统信息查看</h3></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 系统内核</span><br><span class="line">uname -r</span><br><span class="line">-- <span class="number">2.6</span><span class="number">.32</span>-<span class="number">431.</span>el6.x86_64</span><br><span class="line">    </span><br><span class="line"># 系统版本</span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>


<blockquote>
<h3 id="安装编译"><a href="#安装编译" class="headerlink" title="安装编译"></a>安装编译</h3></blockquote>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><code>make</code></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>make PREFIX=/usr/local/redis install</code></p>
<blockquote>
<p>这里多了一个关键字 <strong>PREFIX=</strong> 这个关键字的作用是编译的时候用于指定程序存放的路径。比如我们现在就是指定了redis必须存放在/usr/local/redis目录。假设不添加该关键字Linux会将可执行文件存放在/usr/local/bin目录，库文件会存放在/usr/local/lib目录。配置文件会存放在/usr/local/etc目录。其他的资源文件会存放在usr/local/share目录。这里指定号目录也方便后续的卸载，后续直接rm -rf /usr/local/redis 即可删除redis。</p>
</blockquote>
]]></content>
      <tags>
        <tag>系统-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机安装Linux</title>
    <url>/2021/03/03/%E7%B3%BB%E7%BB%9F/Linux/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Linux/</url>
    <content><![CDATA[<h2 id="安装报错"><a href="#安装报错" class="headerlink" title="安装报错"></a>安装报错</h2><a id="more"></a>

<h3 id="Section-packages-does-not-end-with-end"><a href="#Section-packages-does-not-end-with-end" class="headerlink" title="Section packages does not end with %end"></a>Section packages does not end with %end</h3><p>方法1 ： VM极简安装模式会自动生成一个autoinst.iso，自动索引镜像，将这个删掉就好了：</p>
<p>先将这个centos虚拟机系统关机，然后从我的机算机清单中找到这个菜单，左键点击选中这个菜单，然后右键，会看到设置选项，进去就能看到一个CD/DVD(IDE) autoinst.iso，删掉，重新开启centos虚拟机系统，就能正常安装了</p>
<p>方法2 ： 原因为虚拟机找不到镜像文件，设置方法：</p>
<p><img src="image-20210303144902140.png" alt="image-20210303144902140"></p>
<p><img src="image-20210303144932408.png" alt="image-20210303144932408"></p>
<p>找到自身镜像文件位置即可</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>阿里镜像地址</p>
</blockquote>
<p><a href="https://mirrors.aliyun.com/centos/8/isos/x86_64/">https://mirrors.aliyun.com/centos/8/isos/x86_64/</a></p>
<p>选择</p>
<p><img src="image-20210303145132219.png" alt="image-20210303145132219"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
